# 1 "PreProcTest.cxx"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "PreProcTest.cxx"
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 1 3
# 349 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__config" 1 3
# 15 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__config" 3
       
# 16 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__config" 3
# 110 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__config" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/endian.h" 1 3
# 31 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/endian.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/endian.h" 1 3
# 39 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/endian.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/cdefs.h" 1 3
# 77 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/cdefs.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/cdefs_elf.h" 1 3
# 78 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/cdefs.h" 2 3
# 547 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/cdefs.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/android/api-level.h" 1 3
# 548 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/cdefs.h" 2 3
# 40 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/endian.h" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/machine/endian.h" 1 3
# 32 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/machine/endian.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 1 3
# 31 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 1 3 4
# 149 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 3 4

# 149 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 216 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 426 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 32 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdint.h" 1 3
# 31 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdint.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stdint.h" 1 3 4
# 11 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stdint.h" 3 4
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stdint-gcc.h" 1 3 4
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stdint-gcc.h" 3 4
typedef signed char int8_t;


typedef short int int16_t;


typedef int int32_t;


typedef long int int64_t;


typedef unsigned char uint8_t;


typedef short unsigned int uint16_t;


typedef unsigned int uint32_t;


typedef long unsigned int uint64_t;




typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef short unsigned int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef long unsigned int uint_least64_t;



typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef long unsigned int uint_fast16_t;
typedef long unsigned int uint_fast32_t;
typedef long unsigned int uint_fast64_t;




typedef long int intptr_t;


typedef long unsigned int uintptr_t;




typedef long int intmax_t;
typedef long unsigned int uintmax_t;
# 12 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stdint.h" 2 3 4
# 32 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdint.h" 2 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 2 3


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/types.h" 1 3
# 21 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/types.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/types.h" 1 3
# 19 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/types.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/types.h" 1 3
# 21 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/types.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/int-ll64.h" 1 3
# 21 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/int-ll64.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/bitsperlong.h" 1 3
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/bitsperlong.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/bitsperlong.h" 1 3
# 23 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/bitsperlong.h" 2 3
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/int-ll64.h" 2 3


typedef __signed__ char __s8;
typedef unsigned char __u8;
typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;

__extension__ typedef __signed__ long long __s64;

__extension__ typedef unsigned long long __u64;
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/types.h" 2 3
# 19 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/types.h" 2 3
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/types.h" 2 3


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/posix_types.h" 1 3
# 21 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/posix_types.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/stddef.h" 1 3
# 19 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/stddef.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/compiler.h" 1 3
# 19 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/stddef.h" 2 3
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/posix_types.h" 2 3



typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;

typedef void (*__kernel_sighandler_t)(int);
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/posix_types.h" 1 3
# 19 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/posix_types.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/posix_types.h" 1 3
# 24 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/posix_types.h" 3
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;


typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;


typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;



typedef __kernel_uid_t __kernel_old_uid_t;
typedef __kernel_gid_t __kernel_old_gid_t;



typedef unsigned int __kernel_old_dev_t;
# 76 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm-generic/posix_types.h" 3
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;

typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;


typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;

typedef unsigned short __kernel_gid16_t;
# 19 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/asm/posix_types.h" 2 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/posix_types.h" 2 3
# 25 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/types.h" 2 3


typedef __u16 __le16;

typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;

typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;
# 36 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 2 3



typedef __kernel_gid32_t __gid_t;
typedef __gid_t gid_t;
typedef __kernel_uid32_t __uid_t;
typedef __uid_t uid_t;
typedef __kernel_pid_t __pid_t;
typedef __pid_t pid_t;
typedef uint32_t __id_t;
typedef __id_t id_t;

typedef unsigned long blkcnt_t;
typedef unsigned long blksize_t;
typedef __kernel_caddr_t caddr_t;
typedef __kernel_clock_t clock_t;

typedef __kernel_clockid_t __clockid_t;
typedef __clockid_t clockid_t;

typedef __kernel_daddr_t daddr_t;
typedef unsigned long fsblkcnt_t;
typedef unsigned long fsfilcnt_t;

typedef __kernel_mode_t __mode_t;
typedef __mode_t mode_t;

typedef __kernel_key_t __key_t;
typedef __key_t key_t;

typedef __kernel_ino_t __ino_t;
typedef __ino_t ino_t;

typedef uint32_t __nlink_t;
typedef __nlink_t nlink_t;

typedef void* __timer_t;
typedef __timer_t timer_t;

typedef __kernel_suseconds_t __suseconds_t;
typedef __suseconds_t suseconds_t;


typedef uint32_t __useconds_t;
typedef __useconds_t useconds_t;





typedef uint64_t dev_t;



typedef __kernel_time_t __time_t;
typedef __time_t time_t;
# 101 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 3
typedef __kernel_off_t off_t;
typedef off_t loff_t;
typedef loff_t off64_t;
# 125 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 3
typedef uint32_t __socklen_t;

typedef __socklen_t socklen_t;

typedef __builtin_va_list __va_list;
# 138 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 3
typedef __kernel_ssize_t ssize_t;


typedef unsigned int uint_t;
typedef unsigned int uint;


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/sysmacros.h" 1 3
# 36 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/sysmacros.h" 3
static __inline__ int major(dev_t _dev)
{
  return (_dev >> 8) & 0xfff;
}

static __inline__ int minor(dev_t _dev)
{
  return (_dev & 0xff) | ((_dev >> 12) & 0xfff00);
}

static __inline__ dev_t makedev(int __ma, int __mi)
{
  return ((__ma & 0xfff) << 8) | (__mi & 0xff) | ((__mi & 0xfff00) << 12);
}
# 146 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/types.h" 2 3


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef uint32_t u_int32_t;
typedef uint16_t u_int16_t;
typedef uint8_t u_int8_t;
typedef uint64_t u_int64_t;
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/machine/endian.h" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/endian.h" 1 3
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/machine/endian.h" 2 3
# 41 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/endian.h" 2 3
# 192 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/endian.h" 3
extern "C" {
uint32_t htonl(uint32_t) __attribute__((__const__));
uint16_t htons(uint16_t) __attribute__((__const__));
uint32_t ntohl(uint32_t) __attribute__((__const__));
uint16_t ntohs(uint16_t) __attribute__((__const__));
}
# 32 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/endian.h" 2 3
# 111 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__config" 2 3
# 453 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__config" 3
namespace std {
namespace __ndk1 {
}
using namespace __ndk1 __attribute__((__strong__));
}
# 350 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 1 3
# 15 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/initializer_list" 1 3
# 47 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/initializer_list" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstddef" 1 3
# 38 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstddef" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 1 3 4
# 39 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstddef" 2 3


       
# 42 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstddef" 3


namespace std { namespace __ndk1 {

using ::ptrdiff_t;
using ::size_t;



using ::max_align_t;
# 96 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstddef" 3
} }



namespace std
{
    typedef decltype(nullptr) nullptr_t;
}
# 48 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/initializer_list" 2 3


       
# 51 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/initializer_list" 3


namespace std
{



template<class _Ep>
class __attribute__ ((__visibility__("default"))) initializer_list
{
    const _Ep* __begin_;
    size_t __size_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    initializer_list(const _Ep* __b, size_t __s) throw()
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;

    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    initializer_list() throw() : __begin_(nullptr), __size_(0) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    size_t size() const throw() {return __size_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    const _Ep* begin() const throw() {return __begin_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    const _Ep* end() const throw() {return __begin_ + __size_;}
};

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
const _Ep*
begin(initializer_list<_Ep> __il) throw()
{
    return __il.begin();
}

template<class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
const _Ep*
end(initializer_list<_Ep> __il) throw()
{
    return __il.end();
}



}
# 16 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 1 3
# 597 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 1 3
# 207 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
       
# 208 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3


namespace std { namespace __ndk1 {

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};


template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


template <bool, class _Tp = void> struct __attribute__ ((__visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};


template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;



struct __two {char __lx[2];};



template <class _Tp, _Tp __v>
struct __attribute__ ((__visibility__("default"))) integral_constant
{
    static constexpr const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        constexpr operator value_type() const throw() {return value;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
         constexpr value_type operator ()() const throw() {return value;}

};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_const<_Tp const> : public true_type {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};

template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;




template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};

template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;




template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};

template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;




template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};


template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_null_pointer
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};




template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <> struct __libcpp_is_integral<__int128_t> : public true_type {};
template <> struct __libcpp_is_integral<__uint128_t> : public true_type {};


template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};



template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_rvalue_reference : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_rvalue_reference<_Tp&&> : public true_type {};


template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_reference<_Tp&&> : public true_type {};
# 387 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 402 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 420 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp, class _Up> struct __attribute__ ((__visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};



namespace __libcpp_is_function_imp
{
template <class _Tp> char __test(_Tp*);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source();
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>())) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};







template <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};


namespace __libcpp_is_member_function_pointer_imp {
 template <typename _Tp>
 char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);

 template <typename>
 std::__two __test(...);
};

template <class _Tp> struct __libcpp_is_member_function_pointer
    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(nullptr)) == 1> {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};





template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 510 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__visibility__("default"))) is_scalar<nullptr_t> : public true_type {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};



template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};


template <class _Tp> using add_const_t = typename add_const<_Tp>::type;




template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};


template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;




template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};


template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;




template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_reference<_Tp&&> {typedef _Tp type;};



template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;




template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_lvalue_reference {typedef _Tp& type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_lvalue_reference<_Tp&> {typedef _Tp& type;};
template <> struct __attribute__ ((__visibility__("default"))) add_lvalue_reference<void> {typedef void type;};
template <> struct __attribute__ ((__visibility__("default"))) add_lvalue_reference<const void> {typedef const void type;};
template <> struct __attribute__ ((__visibility__("default"))) add_lvalue_reference<volatile void> {typedef volatile void type;};
template <> struct __attribute__ ((__visibility__("default"))) add_lvalue_reference<const volatile void> {typedef const volatile void type;};


template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;




template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_rvalue_reference {typedef _Tp&& type;};
template <> struct __attribute__ ((__visibility__("default"))) add_rvalue_reference<void> {typedef void type;};
template <> struct __attribute__ ((__visibility__("default"))) add_rvalue_reference<const void> {typedef const void type;};
template <> struct __attribute__ ((__visibility__("default"))) add_rvalue_reference<volatile void> {typedef volatile void type;};
template <> struct __attribute__ ((__visibility__("default"))) add_rvalue_reference<const volatile void> {typedef const volatile void type;};


template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;






template <class _Tp>
typename add_rvalue_reference<_Tp>::type
declval() throw();
# 641 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};


template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;




template <class _Tp> struct __attribute__ ((__visibility__("default"))) add_pointer
    {typedef typename remove_reference<_Tp>::type* type;};


template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;




template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};



template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};



template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};


template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;




template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};


template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




template <class _Tp>
struct __attribute__ ((__visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};


template <class _Tp> using decay_t = typename decay<_Tp>::type;




namespace __is_abstract_imp
{
template <class _Tp> char __test(_Tp (*)[1]);
template <class _Tp> __two __test(...);
}

template <class _Tp, bool = is_class<_Tp>::value>
struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};

template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_abstract : public __libcpp_abstract<_Tp> {};




template <class _Tp> struct __attribute__ ((__visibility__("default")))
is_final : public integral_constant<bool, __is_final(_Tp)> {};






template <class _Bp, class _Dp>
struct __attribute__ ((__visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 837 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
namespace __is_convertible_imp
{


template <class _Tp> typename add_rvalue_reference<_Tp>::type __create();




template <class _Tp> char helper(_Tp);

template <class _Tp, class _Tf>
typename enable_if<sizeof(helper<_Tp>(__create<_Tf>())) == 1, char>::type
    __test(int);
template <class _Tp, class _Tf> __two __test(...);

template <class _Tp, bool _IsArray = is_array<_Tp>::value,
                     bool _IsFunction = is_function<_Tp>::value,
                     bool _IsVoid = is_void<_Tp>::value>
                     struct __is_array_function_or_void {enum {value = 0};};
template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};
template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};
template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};
}

template <class _Tp,
    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
struct __is_convertible_check
{
    static const size_t __v = 0;
};

template <class _Tp>
struct __is_convertible_check<_Tp, 0>
{
    static const size_t __v = sizeof(_Tp);
};

template <class _T1, class _T2,
    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
struct __is_convertible
    : public integral_constant<bool,

        sizeof(__is_convertible_imp::__test<_T2, _T1>(1)) == 1
# 891 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
    >
{};

template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};

template <class _T1> struct __is_convertible<_T1, const typename remove_const<_T1>::type&, 1, 0> : true_type {};

template <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};
template <class _T1> struct __is_convertible<_T1, const typename remove_const<_T1>::type&&, 1, 0> : true_type {};
template <class _T1> struct __is_convertible<_T1, volatile typename remove_volatile<_T1>::type&&, 1, 0> : true_type {};
template <class _T1> struct __is_convertible<_T1, const volatile typename remove_cv<_T1>::type&&, 1, 0> : true_type {};


template <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>
    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};

template <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>
    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};

template <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>
    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};

template <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>
    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};

template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0> : public false_type {};

template <class _T1> struct __is_convertible<_T1, _T1&&, 2, 0> : public true_type {};

template <class _T1> struct __is_convertible<_T1, _T1&, 2, 0> : public true_type {};
template <class _T1> struct __is_convertible<_T1, _T1*, 2, 0> : public true_type {};
template <class _T1> struct __is_convertible<_T1, _T1*const, 2, 0> : public true_type {};
template <class _T1> struct __is_convertible<_T1, _T1*volatile, 2, 0> : public true_type {};
template <class _T1> struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};


template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};


template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};


template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};


template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};

template <class _T1, class _T2> struct __attribute__ ((__visibility__("default"))) is_convertible
    : public __is_convertible<_T1, _T2>
{
    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
};







template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 991 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 1011 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1023 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};



template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{

    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;

};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    static_assert(!is_void<_Aligner>::value, "");
    union type
    {
        _Aligner __align;
        unsigned char __data[_Len];
    };
};


template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
# 1137 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x1>{ struct __attribute__((__aligned__(0x1))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x2>{ struct __attribute__((__aligned__(0x2))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x4>{ struct __attribute__((__aligned__(0x4))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x8>{ struct __attribute__((__aligned__(0x8))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x10>{ struct __attribute__((__aligned__(0x10))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x20>{ struct __attribute__((__aligned__(0x20))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x40>{ struct __attribute__((__aligned__(0x40))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x80>{ struct __attribute__((__aligned__(0x80))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x100>{ struct __attribute__((__aligned__(0x100))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x200>{ struct __attribute__((__aligned__(0x200))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x400>{ struct __attribute__((__aligned__(0x400))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x800>{ struct __attribute__((__aligned__(0x800))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct __attribute__((__aligned__(0x1000))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct __attribute__((__aligned__(0x2000))) type { unsigned char __lx[_Len]; };};


template <size_t _Len>struct __attribute__ ((__visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct __attribute__((__aligned__(0x4000))) type { unsigned char __lx[_Len]; };};
# 1162 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <size_t _I0, size_t ..._In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof__(_Type0),
                                                       __alignof__(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};


template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;




template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef decltype(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote
{
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
    typedef typename __promote<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote<_A1, _A2, void, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
    static const bool __does_not_throw = false;
};
# 1276 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,

    __type_list<__int128_t,

    __nat

    >

    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,

    __type_list<__uint128_t,

    __nat

    >

    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <> struct __make_signed<__int128_t, true> {typedef __int128_t type;};
template <> struct __make_signed<__uint128_t, true> {typedef __int128_t type;};


template <class _Tp>
struct __attribute__ ((__visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;


template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <> struct __make_unsigned<__int128_t, true> {typedef __uint128_t type;};
template <> struct __make_unsigned<__uint128_t, true> {typedef __uint128_t type;};


template <class _Tp>
struct __attribute__ ((__visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};


template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
# 1468 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class ..._Tp> struct common_type;

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) common_type<_Tp>
{
    typedef typename decay<_Tp>::type type;
};

template <class _Tp, class _Up>
struct __attribute__ ((__visibility__("default"))) common_type<_Tp, _Up>
{
private:
    static _Tp&& __t();
    static _Up&& __u();
    static bool __f();
public:
    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;
};

template <class _Tp, class _Up, class ..._Vp>
struct __attribute__ ((__visibility__("default"))) common_type<_Tp, _Up, _Vp...>
{
    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
};


template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;






template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<decltype((std::__ndk1::declval<_Tp>() = std::__ndk1::declval<_Arg>())), true_type>::type

__is_assignable_test(_Tp&&, _Arg&&);




template <class _Arg>
false_type

__is_assignable_test(__any, _Arg&&);




template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public common_type
        <
            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        >::type {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                     const typename add_lvalue_reference<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_move_assignable

    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                     const typename add_rvalue_reference<_Tp>::type> {};






template <class _Tp>
struct __destructible_test
{
    _Tp __t;
};

template <class _Tp>
decltype((std::__ndk1::declval<__destructible_test<_Tp> >().~__destructible_test<_Tp>(), true_type()))

__is_destructible_test(_Tp&&);




false_type
__is_destructible_test(__any);

template <class _Tp, bool = is_void<_Tp>::value || is_abstract<_Tp>::value
                                                || is_function<_Tp>::value>
struct __destructible_imp
    : public common_type
        <
            decltype(__is_destructible_test(declval<_Tp>()))
        >::type {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_imp<_Tp> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public false_type {};





template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename remove_reference<_Tp>::type&&
move(_Tp&& __t) throw()
{
    typedef typename remove_reference<_Tp>::type _Up;
    return static_cast<_Up&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp&&
forward(typename std::remove_reference<_Tp>::type& __t) throw()
{
    return static_cast<_Tp&&>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp&&
forward(typename std::remove_reference<_Tp>::type&& __t) throw()
{
    static_assert(!std::is_lvalue_reference<_Tp>::value,
                  "Can not forward an rvalue as an lvalue.");
    return static_cast<_Tp&&>(__t);
}
# 1665 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename decay<_Tp>::type
__decay_copy(_Tp&& __t)
{
    return std::__ndk1::forward<_Tp>(__t);
}
# 1687 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};



template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};

template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
# 1919 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{



};



template <class _Callable> class result_of;
# 2091 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
namespace __is_construct
{
struct __nat {};
}
# 2109 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp, class ..._Args>
typename __select_2nd<decltype(std::__ndk1::move(_Tp(std::__ndk1::declval<_Args>()...))), true_type>::type
__is_constructible_test(_Tp&&, _Args&& ...);

template <class ..._Args>
false_type
__is_constructible_test(__any, _Args&& ...);

template <bool, class _Tp, class... _Args>
struct __libcpp_is_constructible
    : public common_type
             <
                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))
             >::type
    {};



template <class _Rp, class... _A1, class... _A2>
struct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>
    : public false_type
    {};





template <class _Tp>
struct __libcpp_is_constructible<true, _Tp>
    : public is_scalar<_Tp>
    {};




template <class _Tp>
struct __is_constructible_ref
{
    true_type static __lxx(_Tp);
    false_type static __lxx(...);
};

template <class _Tp, class _A0>
struct __libcpp_is_constructible<true, _Tp, _A0>
    : public common_type
             <
                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))
             >::type
    {};



template <class _Tp, class _A0, class ..._Args>
struct __libcpp_is_constructible<true, _Tp, _A0, _Args...>
    : public false_type
    {};



template <bool, class _Tp, class... _Args>
struct __is_constructible_void_check
    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _Args...>
    {};



template <class _Tp, class... _Args>
struct __is_constructible_void_check<true, _Tp, _Args...>
    : public false_type
    {};

template <class ..._Args> struct __contains_void;

template <> struct __contains_void<> : false_type {};

template <class _A0, class ..._Args>
struct __contains_void<_A0, _Args...>
{
    static const bool value = is_void<_A0>::value ||
                              __contains_void<_Args...>::value;
};



template <class _Tp, class... _Args>
struct __attribute__ ((__visibility__("default"))) is_constructible
    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value
                                        || is_abstract<_Tp>::value,
                                           _Tp, _Args...>
    {};




template <class _Ap, size_t _Np>
struct __libcpp_is_constructible<false, _Ap[_Np]>
    : public is_constructible<typename remove_all_extents<_Ap>::type>
    {};



template <class _Ap, size_t _Np, class ..._Args>
struct __libcpp_is_constructible<false, _Ap[_Np], _Args...>
    : public false_type
    {};



template <class _Ap, class ..._Args>
struct __libcpp_is_constructible<false, _Ap[], _Args...>
    : public false_type
    {};
# 2402 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};



template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_move_constructible

    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};
# 2439 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__ ((__visibility__("default"))) is_trivially_constructible
    : false_type
{
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_trivially_constructible<_Tp>

    : integral_constant<bool, __has_trivial_constructor(_Tp)>



{
};

template <class _Tp>

struct __attribute__ ((__visibility__("default"))) is_trivially_constructible<_Tp, _Tp&&>



    : integral_constant<bool, is_scalar<_Tp>::value>
{
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_trivially_constructible<_Tp, const _Tp&>
    : integral_constant<bool, is_scalar<_Tp>::value>
{
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_trivially_constructible<_Tp, _Tp&>
    : integral_constant<bool, is_scalar<_Tp>::value>
{
};
# 2554 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_move_constructible

    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};
# 2586 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : public false_type {};

template <class _Tp>
struct is_trivially_assignable<_Tp&, _Tp>
    : integral_constant<bool, is_scalar<_Tp>::value> {};

template <class _Tp>
struct is_trivially_assignable<_Tp&, _Tp&>
    : integral_constant<bool, is_scalar<_Tp>::value> {};

template <class _Tp>
struct is_trivially_assignable<_Tp&, const _Tp&>
    : integral_constant<bool, is_scalar<_Tp>::value> {};



template <class _Tp>
struct is_trivially_assignable<_Tp&, _Tp&&>
    : integral_constant<bool, is_scalar<_Tp>::value> {};







template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



    {};





template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};
# 2663 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;

template <class _Tp, class... _Args>
struct __libcpp_is_nothrow_constructible<true, _Tp, _Args...>
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
{
};

template <class _Tp, class... _Args>
struct __libcpp_is_nothrow_constructible<false, _Tp, _Args...>
    : public false_type
{
};

template <class _Tp, class... _Args>
struct __attribute__ ((__visibility__("default"))) is_nothrow_constructible
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__visibility__("default"))) is_nothrow_constructible<_Tp[_Ns]>
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>
{
};
# 2801 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_move_constructible

    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



    {};





template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(std::__ndk1::declval<_Tp>() = std::__ndk1::declval<_Arg>()) >
{
};

template <class _Tp, class _Arg>
struct __attribute__ ((__visibility__("default"))) is_nothrow_assignable
    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
{
};
# 2891 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



    {};





template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__ndk1::declval<_Tp>().~_Tp()) >
{
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};

template <class _Tp, size_t _Ns>
struct __attribute__ ((__visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};



template <class _Tp>
struct __attribute__ ((__visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
# 2968 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 2983 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal_type(_Tp)>




    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivially_copyable



    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>

    {};



template <class _Tp> struct __attribute__ ((__visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};





template <class ..._Tp> struct __check_complete;

template <>
struct __check_complete<>
{
};

template <class _Hp, class _T0, class ..._Tp>
struct __check_complete<_Hp, _T0, _Tp...>
    : private __check_complete<_Hp>,
      private __check_complete<_T0, _Tp...>
{
};

template <class _Hp>
struct __check_complete<_Hp, _Hp>
    : private __check_complete<_Hp>
{
};

template <class _Tp>
struct __check_complete<_Tp>
{
    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
};

template <class _Tp>
struct __check_complete<_Tp&>
    : private __check_complete<_Tp>
{
};

template <class _Tp>
struct __check_complete<_Tp&&>
    : private __check_complete<_Tp>
{
};

template <class _Rp, class ..._Param>
struct __check_complete<_Rp (*)(_Param...)>
    : private __check_complete<_Rp>
{
};

template <class ..._Param>
struct __check_complete<void (*)(_Param...)>
{
};

template <class _Rp, class ..._Param>
struct __check_complete<_Rp (_Param...)>
    : private __check_complete<_Rp>
{
};

template <class ..._Param>
struct __check_complete<void (_Param...)>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...)>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
    : private __check_complete<_Class>
{
};



template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
    : private __check_complete<_Class>
{
};

template <class _Rp, class _Class, class ..._Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
    : private __check_complete<_Class>
{
};



template <class _Rp, class _Class>
struct __check_complete<_Rp _Class::*>
    : private __check_complete<_Class>
{
};





template <class ..._Args>
auto
__invoke(__any, _Args&& ...__args)
    -> __nat;



template <class _Fp, class _A0, class ..._Args,
            class = typename enable_if
            <
                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&
                is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,
                           typename remove_reference<_A0>::type>::value
            >::type
         >
__attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
    -> decltype((std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...));

template <class _Fp, class _A0, class ..._Args,
            class = typename enable_if
            <
                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&
                !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,
                           typename remove_reference<_A0>::type>::value
            >::type
         >
__attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
    -> decltype(((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...));



template <class _Fp, class _A0,
            class = typename enable_if
            <
                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&
                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
                           typename remove_reference<_A0>::type>::value
            >::type
         >
__attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
    -> decltype(std::__ndk1::forward<_A0>(__a0).*__f);

template <class _Fp, class _A0,
            class = typename enable_if
            <
                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&
                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
                           typename remove_reference<_A0>::type>::value
            >::type
         >
__attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
    -> decltype((*std::__ndk1::forward<_A0>(__a0)).*__f);



template <class _Fp, class ..._Args>
__attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _Args&& ...__args)
    -> decltype(std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...));



template <class _Fp, class ..._Args>
struct __invokable_imp
    : private __check_complete<_Fp>
{
    typedef decltype(
            __invoke(std::__ndk1::declval<_Fp>(), std::__ndk1::declval<_Args>()...)
                    ) type;
    static const bool value = !is_same<type, __nat>::value;
};

template <class _Fp, class ..._Args>
struct __invokable
    : public integral_constant<bool,
          __invokable_imp<_Fp, _Args...>::value>
{
};



template <bool _Invokable, class _Fp, class ..._Args>
struct __invoke_of_imp
{
};

template <class _Fp, class ..._Args>
struct __invoke_of_imp<true, _Fp, _Args...>
{
    typedef typename __invokable_imp<_Fp, _Args...>::type type;
};

template <class _Fp, class ..._Args>
struct __invoke_of
    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>
{
};

template <class _Fp, class ..._Args>
class __attribute__ ((__visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...>
{
};


template <class _Tp> using result_of_t = typename result_of<_Tp>::type;




template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))

typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value
>::type



swap(_Tp& __x, _Tp& __y)

{
    _Tp __t(std::__ndk1::move(__x));
    __x = std::__ndk1::move(__y);
    __y = std::__ndk1::move(__t);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

              

{
    swap(*__a, *__b);
}



namespace __detail
{

using std::__ndk1::swap;
__nat swap(__any, __any);

template <class _Tp>
struct __swappable
{
    typedef decltype(swap(std::__ndk1::declval<_Tp&>(), std::__ndk1::declval<_Tp&>())) type;
    static const bool value = !is_same<type, __nat>::value;
};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
{
};



template <bool, class _Tp>
struct __is_nothrow_swappable_imp
    : public integral_constant<bool, noexcept(swap(std::__ndk1::declval<_Tp&>(),
                                                   std::__ndk1::declval<_Tp&>()))>
{
};

template <class _Tp>
struct __is_nothrow_swappable_imp<false, _Tp>
    : public false_type
{
};

template <class _Tp>
struct __is_nothrow_swappable
    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>
{
};
# 3378 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};


template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
# 3402 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/type_traits" 3
template <class _Tp>
struct __has_operator_addressof_imp
{
    template <class>
        static auto __test(__any) -> false_type;
    template <class _Up>
        static auto __test(_Up* __u)
            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;

    static const bool value = decltype(__test<_Tp>(nullptr))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>
{};



} }
# 598 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/typeinfo" 1 3
# 61 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/typeinfo" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/exception" 1 3
# 84 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/exception" 3
       
# 85 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/exception" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception() throw() {}
    virtual ~exception() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_exception
    : public exception
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bad_exception() throw() {}
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
};

typedef void (*unexpected_handler)();
__attribute__ ((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) throw();
__attribute__ ((__visibility__("default"))) unexpected_handler get_unexpected() throw();
__attribute__((noreturn)) __attribute__ ((__visibility__("default"))) void unexpected();

typedef void (*terminate_handler)();
__attribute__ ((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) throw();
__attribute__ ((__visibility__("default"))) terminate_handler get_terminate() throw();

__attribute__((noreturn)) __attribute__ ((__visibility__("default"))) void terminate() throw();




__attribute__ ((__visibility__("default"))) bool uncaught_exception() throw();

class __attribute__ ((__visibility__("default"))) exception_ptr;

__attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
__attribute__((noreturn)) __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);

class __attribute__ ((__visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr() throw() : __ptr_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr(nullptr_t) throw() : __ptr_() {}
    exception_ptr(const exception_ptr&) throw();
    exception_ptr& operator=(const exception_ptr&) throw();
    ~exception_ptr() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit
        operator bool() const throw() {return __ptr_ != nullptr;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) throw()
        {return !(__x == __y);}

    friend __attribute__ ((__visibility__("default"))) exception_ptr current_exception() throw();
    friend __attribute__ ((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template<class _Ep>
exception_ptr
make_exception_ptr(_Ep __e) throw()
{
# 167 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/exception" 3
}



class __attribute__ ((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() throw();


    virtual ~nested_exception() throw();


    __attribute__((noreturn)) void rethrow_nested() const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) exception_ptr nested_ptr() const throw() {return __ptr_;}
};

template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};

template <class _Tp>
__attribute__((noreturn))
void

throw_with_nested(_Tp&& __t, typename enable_if<
                  is_class<typename remove_reference<_Tp>::type>::value &&
                  !is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value
                                    >::type* = 0)





{



}

template <class _Tp>
__attribute__((noreturn))
void

throw_with_nested(_Tp&& __t, typename enable_if<
                  !is_class<typename remove_reference<_Tp>::type>::value ||
                  is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value
                                    >::type* = 0)





{



}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep& __e, typename enable_if<
                                   is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(&__e);
    if (__nep)
        __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
rethrow_if_nested(const _Ep&, typename enable_if<
                                   !is_polymorphic<_Ep>::value
                                                   >::type* = 0)
{
}

}
# 62 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/typeinfo" 2 3

# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstdint" 1 3
# 148 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstdint" 3
       
# 149 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstdint" 3


namespace std { namespace __ndk1 {

using::int8_t;
using::int16_t;
using::int32_t;
using::int64_t;

using::uint8_t;
using::uint16_t;
using::uint32_t;
using::uint64_t;

using::int_least8_t;
using::int_least16_t;
using::int_least32_t;
using::int_least64_t;

using::uint_least8_t;
using::uint_least16_t;
using::uint_least32_t;
using::uint_least64_t;

using::int_fast8_t;
using::int_fast16_t;
using::int_fast32_t;
using::int_fast64_t;

using::uint_fast8_t;
using::uint_fast16_t;
using::uint_fast32_t;
using::uint_fast64_t;

using::intptr_t;
using::uintptr_t;

using::intmax_t;
using::uintmax_t;

} }
# 64 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/typeinfo" 2 3


       
# 67 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/typeinfo" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) type_info
{
    type_info& operator=(const type_info&);
    type_info(const type_info&);
protected:

    const char* __type_name;





    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit type_info(const char* __n)

        : __type_name(__n) {}




public:
    virtual ~type_info();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const char* name() const throw()

        {return __type_name;}




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool before(const type_info& __arg) const throw()

        {return __type_name < __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t hash_code() const throw()

        {return *reinterpret_cast<const size_t*>(&__type_name);}
# 126 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/typeinfo" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const type_info& __arg) const throw()

        {return __type_name == __arg.__type_name;}






    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const type_info& __arg) const throw()
        {return !operator==(__arg);}







};

class __attribute__ ((__visibility__("default"))) bad_cast
    : public exception
{
public:
    bad_cast() throw();
    virtual ~bad_cast() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_typeid
    : public exception
{
public:
    bad_typeid() throw();
    virtual ~bad_typeid() throw();
    virtual const char* what() const throw();
};

}
# 599 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/new" 1 3
# 72 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/new" 3
       
# 73 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/new" 3


namespace std
{

class __attribute__ ((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() throw();
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() throw();
    virtual ~bad_array_new_length() throw();
    virtual const char* what() const throw();
};



class __attribute__ ((__visibility__("default"))) bad_array_length
    : public bad_alloc
{
public:
    bad_array_length() throw();
    virtual ~bad_array_length() throw();
    virtual const char* what() const throw();
};





__attribute__ ((__visibility__("default"))) void __throw_bad_alloc();

struct __attribute__ ((__visibility__("default"))) nothrow_t {};
extern __attribute__ ((__visibility__("default"))) const nothrow_t nothrow;
typedef void (*new_handler)();
__attribute__ ((__visibility__("default"))) new_handler set_new_handler(new_handler) throw();
__attribute__ ((__visibility__("default"))) new_handler get_new_handler() throw();

}







__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete(void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) throw();

__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz)

    throw(std::bad_alloc)

;
__attribute__ ((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p) throw();
__attribute__ ((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) throw();

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new (std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* operator new[](std::size_t, void* __p) throw() {return __p;}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete (void*, void*) throw() {}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator delete[](void*, void*) throw() {}
# 602 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/utility" 1 3
# 157 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/utility" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__tuple" 1 3
# 19 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__tuple" 3
       
# 20 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__tuple" 3
# 28 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__tuple" 3
namespace std { namespace __ndk1 {

template <class _Tp> class __attribute__ ((__visibility__("default"))) tuple_size;

template <class _Tp>
class __attribute__ ((__visibility__("default"))) tuple_size<const _Tp>
    : public tuple_size<_Tp> {};

template <class _Tp>
class __attribute__ ((__visibility__("default"))) tuple_size<volatile _Tp>
    : public tuple_size<_Tp> {};

template <class _Tp>
class __attribute__ ((__visibility__("default"))) tuple_size<const volatile _Tp>
    : public tuple_size<_Tp> {};

template <size_t _Ip, class _Tp> class __attribute__ ((__visibility__("default"))) tuple_element;

template <size_t _Ip, class _Tp>
class __attribute__ ((__visibility__("default"))) tuple_element<_Ip, const _Tp>
{
public:
    typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
class __attribute__ ((__visibility__("default"))) tuple_element<_Ip, volatile _Tp>
{
public:
    typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
class __attribute__ ((__visibility__("default"))) tuple_element<_Ip, const volatile _Tp>
{
public:
    typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class ..._Tp> class __attribute__ ((__visibility__("default"))) tuple;
template <class _T1, class _T2> struct __attribute__ ((__visibility__("default"))) pair;
template <class _Tp, size_t _Size> struct __attribute__ ((__visibility__("default"))) array;

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};

template <class... _Tp> struct __tuple_like<tuple<_Tp...> > : true_type {};
template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {};
template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {};

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) throw();

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) throw();

template <size_t _Ip, class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) throw();

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) throw();

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) throw();

template <size_t _Ip, class _T1, class _T2>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) throw();

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp&
get(array<_Tp, _Size>&) throw();

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
get(const array<_Tp, _Size>&) throw();

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp&&
get(array<_Tp, _Size>&&) throw();



template <size_t...> struct __tuple_indices {};

template <size_t _Sp, class _IntTuple, size_t _Ep>
struct __make_indices_imp;

template <size_t _Sp, size_t ..._Indices, size_t _Ep>
struct __make_indices_imp<_Sp, __tuple_indices<_Indices...>, _Ep>
{
    typedef typename __make_indices_imp<_Sp+1, __tuple_indices<_Indices..., _Sp>, _Ep>::type type;
};

template <size_t _Ep, size_t ..._Indices>
struct __make_indices_imp<_Ep, __tuple_indices<_Indices...>, _Ep>
{
    typedef __tuple_indices<_Indices...> type;
};

template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef typename __make_indices_imp<_Sp, __tuple_indices<>, _Ep>::type type;
};



template <class ..._Tp> struct __tuple_types {};

template <size_t _Ip>
class __attribute__ ((__visibility__("default"))) tuple_element<_Ip, __tuple_types<> >
{
public:
    static_assert(_Ip == 0, "tuple_element index out of range");
    static_assert(_Ip != 0, "tuple_element index out of range");
};

template <class _Hp, class ..._Tp>
class __attribute__ ((__visibility__("default"))) tuple_element<0, __tuple_types<_Hp, _Tp...> >
{
public:
    typedef _Hp type;
};

template <size_t _Ip, class _Hp, class ..._Tp>
class __attribute__ ((__visibility__("default"))) tuple_element<_Ip, __tuple_types<_Hp, _Tp...> >
{
public:
    typedef typename tuple_element<_Ip-1, __tuple_types<_Tp...> >::type type;
};

template <class ..._Tp>
class __attribute__ ((__visibility__("default"))) tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};

template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {};
# 193 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__tuple" 3
template <class _TupleTypes, class _Tp, size_t _Sp, size_t _Ep>
struct __make_tuple_types_imp;

template <class ..._Types, class _Tp, size_t _Sp, size_t _Ep>
struct __make_tuple_types_imp<__tuple_types<_Types...>, _Tp, _Sp, _Ep>
{
    typedef typename remove_reference<_Tp>::type _Tpr;
    typedef typename __make_tuple_types_imp<__tuple_types<_Types...,
                                            typename conditional<is_lvalue_reference<_Tp>::value,
                                                typename tuple_element<_Sp, _Tpr>::type&,
                                                typename tuple_element<_Sp, _Tpr>::type>::type>,
                                            _Tp, _Sp+1, _Ep>::type type;
};

template <class ..._Types, class _Tp, size_t _Ep>
struct __make_tuple_types_imp<__tuple_types<_Types...>, _Tp, _Ep, _Ep>
{
    typedef __tuple_types<_Types...> type;
};

template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value, size_t _Sp = 0>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    typedef typename __make_tuple_types_imp<__tuple_types<>, _Tp, _Sp, _Ep>::type type;
};



template <bool, class _Tp, class _Up>
struct __tuple_convertible_imp : public false_type {};

template <class _Tp0, class ..._Tp, class _Up0, class ..._Up>
struct __tuple_convertible_imp<true, __tuple_types<_Tp0, _Tp...>, __tuple_types<_Up0, _Up...> >
    : public integral_constant<bool,
                               is_convertible<_Tp0, _Up0>::value &&
                               __tuple_convertible_imp<true, __tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {};

template <>
struct __tuple_convertible_imp<true, __tuple_types<>, __tuple_types<> >
    : public true_type {};

template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_convertible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_convertible_imp<tuple_size<typename remove_reference<_Tp>::type>::value ==
                                     tuple_size<_Up>::value,
             typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type>
{};



template <bool, class _Tp, class _Up>
struct __tuple_constructible_imp : public false_type {};

template <class _Tp0, class ..._Tp, class _Up0, class ..._Up>
struct __tuple_constructible_imp<true, __tuple_types<_Tp0, _Tp...>, __tuple_types<_Up0, _Up...> >
    : public integral_constant<bool,
                               is_constructible<_Up0, _Tp0>::value &&
                               __tuple_constructible_imp<true, __tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {};

template <>
struct __tuple_constructible_imp<true, __tuple_types<>, __tuple_types<> >
    : public true_type {};

template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_constructible
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_constructible_imp<tuple_size<typename remove_reference<_Tp>::type>::value ==
                                     tuple_size<_Up>::value,
             typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type>
{};



template <bool, class _Tp, class _Up>
struct __tuple_assignable_imp : public false_type {};

template <class _Tp0, class ..._Tp, class _Up0, class ..._Up>
struct __tuple_assignable_imp<true, __tuple_types<_Tp0, _Tp...>, __tuple_types<_Up0, _Up...> >
    : public integral_constant<bool,
                               is_assignable<_Up0&, _Tp0>::value &&
                               __tuple_assignable_imp<true, __tuple_types<_Tp...>, __tuple_types<_Up...> >::value> {};

template <>
struct __tuple_assignable_imp<true, __tuple_types<>, __tuple_types<> >
    : public true_type {};

template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
                                bool = __tuple_like<_Up>::value>
struct __tuple_assignable
    : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_assignable_imp<tuple_size<typename remove_reference<_Tp>::type>::value ==
                                    tuple_size<_Up>::value,
             typename __make_tuple_types<_Tp>::type, typename __make_tuple_types<_Up>::type>
{};

} }
# 158 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/utility" 2 3



       
# 162 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/utility" 3


namespace std { namespace __ndk1 {

namespace rel_ops
{

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}

}



template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    for(; __first1 != __last1; ++__first1, ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}

template<class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
{
    std::__ndk1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr

typename conditional
<
    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,
    const _Tp&,
    _Tp&&
>::type



move_if_noexcept(_Tp& __x) throw()
{
    return std::__ndk1::move(__x);
}

struct __attribute__ ((__visibility__("default"))) piecewise_construct_t { };



constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


template <class _T1, class _T2>
struct __attribute__ ((__visibility__("default"))) pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;




    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr pair() : first(), second() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    pair(const _T1& __x, const _T2& __y)
        : first(__x), second(__y) {}

    template<class _U1, class _U2>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        pair(const pair<_U1, _U2>& __p

                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&
                                    is_convertible<const _U2&, _T2>::value>::type* = 0

                                      )
            : first(__p.first), second(__p.second) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair(const pair& __p) = default;
# 289 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair& operator=(const pair& __p)
       

    {
        first = __p.first;
        second = __p.second;
        return *this;
    }



    template <class _U1, class _U2,
              class = typename enable_if<is_convertible<_U1, first_type>::value &&
                                         is_convertible<_U2, second_type>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        pair(_U1&& __u1, _U2&& __u2)
            : first(std::__ndk1::forward<_U1>(__u1)),
              second(std::__ndk1::forward<_U2>(__u2))
            {}

    template<class _U1, class _U2>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        pair(pair<_U1, _U2>&& __p,
                 typename enable_if<is_convertible<_U1, _T1>::value &&
                                    is_convertible<_U2, _T2>::value>::type* = 0)
            : first(std::__ndk1::forward<_U1>(__p.first)),
              second(std::__ndk1::forward<_U2>(__p.second)) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair(pair&& __p) = default;
# 331 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/utility" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair&
    operator=(pair&& __p)

    {
        first = std::__ndk1::forward<first_type>(__p.first);
        second = std::__ndk1::forward<second_type>(__p.second);
        return *this;
    }



    template<class _Tuple,
             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        pair(_Tuple&& __p)
            : first(std::__ndk1::forward<typename tuple_element<0,
                                  typename __make_tuple_types<_Tuple>::type>::type>(get<0>(__p))),
              second(std::__ndk1::forward<typename tuple_element<1,
                                   typename __make_tuple_types<_Tuple>::type>::type>(get<1>(__p)))
            {}



    template <class... _Args1, class... _Args2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                                    tuple<_Args2...> __second_args)
            : pair(__pc, __first_args, __second_args,
                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                   typename __make_tuple_indices<sizeof...(_Args2) >::type())
            {}

    template <class _Tuple,
              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair&
        operator=(_Tuple&& __p)
        {
            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;
            typedef typename tuple_element<0, _TupleRef>::type _U0;
            typedef typename tuple_element<1, _TupleRef>::type _U1;
            first = std::__ndk1::forward<_U0>(std::__ndk1::get<0>(__p));
            second = std::__ndk1::forward<_U1>(std::__ndk1::get<1>(__p));
            return *this;
        }




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void
    swap(pair& __p)

    {
        std::__ndk1::iter_swap(&first, &__p.first);
        std::__ndk1::iter_swap(&second, &__p.second);
    }
private:


    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair(piecewise_construct_t,
             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
             __tuple_indices<_I1...>, __tuple_indices<_I2...>);

};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                    

{
    __x.swap(__y);
}



template <class _Tp> class __attribute__ ((__visibility__("default"))) reference_wrapper;

template <class _Tp>
struct __make_pair_return_impl
{
    typedef _Tp type;
};

template <class _Tp>
struct __make_pair_return_impl<reference_wrapper<_Tp>>
{
    typedef _Tp& type;
};

template <class _Tp>
struct __make_pair_return
{
    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>
               (std::__ndk1::forward<_T1>(__t1), std::__ndk1::forward<_T2>(__t2));
}
# 506 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/utility" 3
template <class _T1, class _T2>
  class __attribute__ ((__visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
  class __attribute__ ((__visibility__("default"))) tuple_size<const pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
class __attribute__ ((__visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
public:
    typedef _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
public:
    typedef _T2 type;
};

template <class _T1, class _T2>
class __attribute__ ((__visibility__("default"))) tuple_element<0, const pair<_T1, _T2> >
{
public:
    typedef const _T1 type;
};

template <class _T1, class _T2>
class __attribute__ ((__visibility__("default"))) tuple_element<1, const pair<_T1, _T2> >
{
public:
    typedef const _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _T1&
    get(pair<_T1, _T2>& __p) throw() {return __p.first;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    const _T1&
    get(const pair<_T1, _T2>& __p) throw() {return __p.first;}



    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _T1&&
    get(pair<_T1, _T2>&& __p) throw() {return std::__ndk1::forward<_T1>(__p.first);}


};

template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _T2&
    get(pair<_T1, _T2>& __p) throw() {return __p.second;}

    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    const _T2&
    get(const pair<_T1, _T2>& __p) throw() {return __p.second;}



    template <class _T1, class _T2>
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    _T2&&
    get(pair<_T1, _T2>&& __p) throw() {return std::__ndk1::forward<_T2>(__p.second);}


};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) throw()
{
    return __get_pair<_Ip>::get(__p);
}



template <size_t _Ip, class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) throw()
{
    return __get_pair<_Ip>::get(std::__ndk1::move(__p));
}




template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 & get(pair<_T1, _T2>& __p) throw()
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const & get(pair<_T1, _T2> const& __p) throw()
{
    return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 && get(pair<_T1, _T2>&& __p) throw()
{
    return __get_pair<0>::get(std::__ndk1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 & get(pair<_T2, _T1>& __p) throw()
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const & get(pair<_T2, _T1> const& __p) throw()
{
    return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 && get(pair<_T2, _T1>&& __p) throw()
{
    return __get_pair<1>::get(std::__ndk1::move(__p));
}





template<class _Tp, _Tp... _Ip>
struct __attribute__ ((__visibility__("default"))) integer_sequence
{
    typedef _Tp value_type;
    static_assert( is_integral<_Tp>::value,
                  "std::integer_sequence can only be instantiated with an integral type" );
    static
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr
    size_t
    size() noexcept { return sizeof...(_Ip); }
};

template<size_t... _Ip>
    using index_sequence = integer_sequence<size_t, _Ip...>;

namespace __detail {

template<typename _Tp, size_t ..._Extra> struct __repeat;
template<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {
  typedef integer_sequence<_Tp,
                           _Np...,
                           sizeof...(_Np) + _Np...,
                           2 * sizeof...(_Np) + _Np...,
                           3 * sizeof...(_Np) + _Np...,
                           4 * sizeof...(_Np) + _Np...,
                           5 * sizeof...(_Np) + _Np...,
                           6 * sizeof...(_Np) + _Np...,
                           7 * sizeof...(_Np) + _Np...,
                           _Extra...> type;
};

template<size_t _Np> struct __parity;
template<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};

template<> struct __make<0> { typedef integer_sequence<size_t> type; };
template<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };
template<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };
template<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };
template<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };
template<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };
template<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };
template<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };

template<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };
template<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };
template<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };
template<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };
template<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };
template<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };
template<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };
template<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };

template<typename _Tp, typename _Up> struct __convert {
  template<typename> struct __result;
  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };
};
template<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };

}

template<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =
  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;

template <class _Tp, _Tp _Ep>
struct __make_integer_sequence
{
    static_assert(is_integral<_Tp>::value,
                  "std::make_integer_sequence can only be instantiated with an integral type" );
    static_assert(0 <= _Ep, "std::make_integer_sequence input shall not be negative");
    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;
};

template<class _Tp, _Tp _Np>
    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;

template<size_t _Np>
    using make_index_sequence = make_integer_sequence<size_t, _Np>;

template<class... _Tp>
    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;




template<class _T1, class _T2 = _T1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_T1 exchange(_T1& __obj, _T2 && __new_value)
{
    _T1 __old_value = std::__ndk1::move(__obj);
    __obj = std::__ndk1::forward<_T2>(__new_value);
    return __old_value;
}


} }
# 603 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/limits" 1 3
# 106 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/limits" 3
       
# 107 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/limits" 3





# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__undef_min_max" 1 3
# 113 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/limits" 2 3
# 122 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/limits" 3
namespace std { namespace __ndk1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return type();}

    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return type();}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return type();}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int digits, bool is_signed>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << digits);
};

template <class _Tp, int digits>
struct __libcpp_compute_min<_Tp, digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = true;




    static constexpr const bool traps = false;

    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return min();}

    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return type(0);}

    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;

    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return type(0);}

    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return 1.17549435082228750796873653722224568e-38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return 3.40282346638528859811704183484516925e+38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return 1.19209289550781250000000000000000000e-7F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return 0.5F;}

    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return 1.40129846432481707092372958328991613e-45F;}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return double(2.22507385850720138309023271733240406e-308L);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return double(1.79769313486231570814527423731704357e+308L);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return double(2.22044604925031308084726333618164062e-16L);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return 0.5;}

    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return double(4.94065645841246544176568792868221372e-324L);}

    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static constexpr const bool is_specialized = true;

    static constexpr const bool is_signed = true;
    static constexpr const int digits = 113;
    static constexpr const int digits10 = 33;
    static constexpr const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return 3.36210314311209350626267781732175260e-4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return 1.18973149535723176508575932662800702e+4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return -max();}

    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return 1.92592994438723585305597794258492732e-34L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return 0.5;}

    static constexpr const int min_exponent = (-16381);
    static constexpr const int min_exponent10 = (-4931);
    static constexpr const int max_exponent = 16384;
    static constexpr const int max_exponent10 = 4932;

    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return 6.47517511943802511092443895822764655e-4966L;}




    static constexpr const bool is_iec559 = true;

    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;

    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() throw() {return __base::lowest();}

    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type round_error() throw() {return __base::round_error();}

    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;

    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static constexpr type denorm_min() throw() {return __base::denorm_min();}

    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;

    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 604 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iterator" 1 3
# 332 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iterator" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__functional_base" 1 3
# 21 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__functional_base" 3
       
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__functional_base" 3


namespace std { namespace __ndk1 {

template <class _Arg, class _Result>
struct __attribute__ ((__visibility__("default"))) unary_function
{
    typedef _Arg argument_type;
    typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__ ((__visibility__("default"))) binary_function
{
    typedef _Arg1 first_argument_type;
    typedef _Arg2 second_argument_type;
    typedef _Result result_type;
};

template <class _Tp> struct __attribute__ ((__visibility__("default"))) hash;

template <class _Tp>
struct __has_result_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::result_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};


template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) less : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) less<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) < std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
addressof(_Tp& __x) throw()
{
    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);
}
# 136 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__functional_base" 3
template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static unary_function<_Ap, _Rp>
        __test(const volatile unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static binary_function<_A1, _A2, _Rp>
        __test(const volatile binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
    typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};

template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};



template <class _Rp>
struct __weak_result_type<_Rp ()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
    typedef _Rp result_type;
};

template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
    typedef _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public unary_function<_Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp*, _Rp>
{
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp*, _Rp>
{
};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp*, _A1, _Rp>
{
};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp*, _A1, _Rp>
{
};



template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
    typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
    typedef _Rp result_type;
};





template <class _Fp, class _A0, class ..._Args,
            class>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
    -> decltype((std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...))
{
    return (std::__ndk1::forward<_A0>(__a0).*__f)(std::__ndk1::forward<_Args>(__args)...);
}

template <class _Fp, class _A0, class ..._Args,
            class>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
    -> decltype(((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...))
{
    return ((*std::__ndk1::forward<_A0>(__a0)).*__f)(std::__ndk1::forward<_Args>(__args)...);
}



template <class _Fp, class _A0,
            class>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
    -> decltype(std::__ndk1::forward<_A0>(__a0).*__f)
{
    return std::__ndk1::forward<_A0>(__a0).*__f;
}

template <class _Fp, class _A0,
            class>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _A0&& __a0)
    -> decltype((*std::__ndk1::forward<_A0>(__a0)).*__f)
{
    return (*std::__ndk1::forward<_A0>(__a0)).*__f;
}



template <class _Fp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
auto
__invoke(_Fp&& __f, _Args&& ...__args)
    -> decltype(std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...))
{
    return std::__ndk1::forward<_Fp>(__f)(std::__ndk1::forward<_Args>(__args)...);
}

template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(__invoke(std::__ndk1::declval<_Tp>(), std::__ndk1::declval<_Args>()...)) type;
};

template <class _Tp>
class __attribute__ ((__visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type* __f_;

public:

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference_wrapper(type& __f) throw()
        : __f_(std::__ndk1::addressof(__f)) {}

    private: reference_wrapper(type&&); public:



    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator type& () const throw() {return *__f_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) type& get() const throw() {return *__f_;}


    template <class... _ArgTypes>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_of<type&, _ArgTypes...>::type
          operator() (_ArgTypes&&... __args) const
          {
              return __invoke(get(), std::__ndk1::forward<_ArgTypes>(__args)...);
          }
};

template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(_Tp& __t) throw()
{
    return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) throw()
{
    return ref(__t.get());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(const _Tp& __t) throw()
{
    return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) throw()
{
    return cref(__t.get());
}




template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;
# 509 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__functional_base" 3
template <class _Tp1, class _Tp2 = void>
struct __is_transparent
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::is_transparent* = 0);
public:
    static const bool value = sizeof(__test<_Tp1>(0)) == 1;
};




struct __attribute__ ((__visibility__("default"))) allocator_arg_t { };




constexpr allocator_arg_t allocator_arg = allocator_arg_t();




template <class _Tp>
struct __has_allocator_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};

template <class _Tp, class _Alloc>
struct __attribute__ ((__visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};





template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::__ndk1::forward<_Args>(__args)...);
}

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::__ndk1::forward<_Args>(__args)...);
}

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::__ndk1::forward<_Args>(__args)..., __a);
}

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)
{
    __user_alloc_construct_impl(
             __uses_alloc_ctor<_Tp, _Allocator>(),
             __storage, __a, std::__ndk1::forward<_Args>(__args)...
        );
}


} }
# 333 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iterator" 2 3


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iosfwd" 1 3
# 90 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iosfwd" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/wchar.h" 1 3
# 66 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/wchar.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/wchar.h" 1 3
# 32 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/wchar.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdio.h" 1 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdio.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 1 3
# 52 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stdarg.h" 1 3 4
# 40 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 99 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 53 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 1 3 4
# 54 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 2 3


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 1 3 4
# 57 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 2 3



typedef off_t fpos_t;
# 70 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 3
struct __sbuf {
  unsigned char* _base;
  size_t _size;
};
# 108 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 3
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;

 int _flags;
 int _file;




 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read)(void *, char *, int);
 fpos_t (*_seek)(void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ext;

 unsigned char *_up;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE __sF[];
}
# 219 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 3
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
char *fgets(char * __restrict, int, FILE * __restrict);
FILE *fopen(const char * __restrict , const char * __restrict);
int fprintf(FILE * __restrict , const char * __restrict, ...)
  __attribute__((__format__(printf, 2, 3))) __attribute__((__nonnull__ (2)));
int fputc(int, FILE *);
int fputs(const char * __restrict, FILE * __restrict);
size_t fread(void * __restrict, size_t, size_t, FILE * __restrict);
FILE *freopen(const char * __restrict, const char * __restrict,
     FILE * __restrict);
int fscanf(FILE * __restrict, const char * __restrict, ...)
  __attribute__((__format__(scanf, 2, 3))) __attribute__((__nonnull__ (2)));
int fseek(FILE *, long, int);
long ftell(FILE *);
size_t fwrite(const void * __restrict, size_t, size_t, FILE * __restrict);
int getc(FILE *);
int getchar(void);
ssize_t getdelim(char ** __restrict, size_t * __restrict, int,
     FILE * __restrict);
ssize_t getline(char ** __restrict, size_t * __restrict, FILE * __restrict);

void perror(const char *);
int printf(const char * __restrict, ...)
  __attribute__((__format__(printf, 1, 2))) __attribute__((__nonnull__ (1)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
void rewind(FILE *);
int scanf(const char * __restrict, ...)
  __attribute__((__format__(scanf, 1, 2))) __attribute__((__nonnull__ (1)));
void setbuf(FILE * __restrict, char * __restrict);
int setvbuf(FILE * __restrict, char * __restrict, int, size_t);
int sscanf(const char * __restrict, const char * __restrict, ...)
  __attribute__((__format__(scanf, 2, 3))) __attribute__((__nonnull__ (2)));
FILE *tmpfile(void);
int ungetc(int, FILE *);
int vfprintf(FILE * __restrict, const char * __restrict, __va_list)
  __attribute__((__format__(printf, 2, 0))) __attribute__((__nonnull__ (2)));
int vprintf(const char * __restrict, __va_list)
  __attribute__((__format__(printf, 1, 0))) __attribute__((__nonnull__ (1)));

int dprintf(int, const char * __restrict, ...) __attribute__((__format__(printf, 2, 3))) __attribute__((__nonnull__ (2)));
int vdprintf(int, const char * __restrict, __va_list) __attribute__((__format__(printf, 2, 0))) __attribute__((__nonnull__ (2)));



char* gets(char*) __attribute__((__warning__("gets is very unsafe; consider using fgets")));

int sprintf(char* __restrict, const char* __restrict, ...)
    __attribute__((__format__(printf, 2, 3))) __attribute__((__nonnull__ (2)));
char* tmpnam(char*) __attribute__((__warning__("tmpnam possibly used unsafely; consider using mkstemp")));
int vsprintf(char* __restrict, const char* __restrict, __va_list)
    __attribute__((__format__(printf, 2, 0))) __attribute__((__nonnull__ (2)));

char* tempnam(const char*, const char*)
    __attribute__((__warning__("tempnam possibly used unsafely; consider using mkstemp")));



extern int rename(const char*, const char*);
extern int renameat(int, const char*, int, const char*);

int fgetpos(FILE * __restrict, fpos_t * __restrict);
int fsetpos(FILE *, const fpos_t *);

int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);


int snprintf(char * __restrict, size_t, const char * __restrict, ...)
  __attribute__((__format__(printf, 3, 4))) __attribute__((__nonnull__ (3)));
int vfscanf(FILE * __restrict, const char * __restrict, __va_list)
  __attribute__((__format__(scanf, 2, 0))) __attribute__((__nonnull__ (2)));
int vscanf(const char *, __va_list)
  __attribute__((__format__(scanf, 1, 0))) __attribute__((__nonnull__ (1)));
int vsnprintf(char * __restrict, size_t, const char * __restrict, __va_list)
  __attribute__((__format__(printf, 3, 0))) __attribute__((__nonnull__ (3)));
int vsscanf(const char * __restrict, const char * __restrict, __va_list)
  __attribute__((__format__(scanf, 2, 0))) __attribute__((__nonnull__ (2)));


}
# 316 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/stdio.h" 3
extern "C" {
FILE *fdopen(int, const char *);
int fileno(FILE *);


int pclose(FILE *);
FILE *popen(const char *, const char *);



void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);





int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);


}







extern "C" {
int asprintf(char ** __restrict, const char * __restrict, ...)
  __attribute__((__format__(printf, 2, 3))) __attribute__((__nonnull__ (2)));
char *fgetln(FILE * __restrict, size_t * __restrict);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** __restrict, const char * __restrict,
    __va_list)
  __attribute__((__format__(printf, 2, 0))) __attribute__((__nonnull__ (2)));
}




extern "C" {
FILE *funopen(const void *,
  int (*)(void *, char *, int),
  int (*)(void *, const char *, int),
  fpos_t (*)(void *, fpos_t, int),
  int (*)(void *));
}
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdio.h" 2 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/wchar.h" 2 3


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 1 3 4
# 36 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/wchar.h" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/time.h" 1 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/time.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/time.h" 1 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/time.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/time.h" 1 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/time.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/time.h" 1 3
# 25 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/time.h" 3
struct timespec {
 __kernel_time_t tv_sec;
 long tv_nsec;

};

struct timeval {
 __kernel_time_t tv_sec;

 __kernel_suseconds_t tv_usec;
};
struct timezone {
 int tz_minuteswest;

 int tz_dsttime;
};




struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;

};
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;

};
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/time.h" 2 3

extern "C" {

extern int gettimeofday(struct timeval *, struct timezone *);
extern int settimeofday(const struct timeval *, const struct timezone *);

extern int getitimer(int, struct itimerval *);
extern int setitimer(int, const struct itimerval *, struct itimerval *);

extern int utimes(const char *, const struct timeval *);
# 76 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/time.h" 3
}
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/time.h" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/xlocale.h" 1 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/xlocale.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/xlocale.h" 1 3
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/xlocale.h" 3
struct __locale_t;
typedef struct __locale_t* locale_t;
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/xlocale.h" 2 3
# 35 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/time.h" 2 3

extern "C" {



extern char* tzname[] __attribute__((visibility ("default")));
extern int daylight __attribute__((visibility ("default")));
extern long int timezone __attribute__((visibility ("default")));

struct sigevent;

struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long int tm_gmtoff;
  const char* tm_zone;
};



extern time_t time(time_t*) __attribute__((visibility ("default")));
extern int nanosleep(const struct timespec*, struct timespec*) __attribute__((visibility ("default")));

extern char* asctime(const struct tm*) __attribute__((visibility ("default")));
extern char* asctime_r(const struct tm*, char*) __attribute__((visibility ("default")));

extern double difftime(time_t, time_t) __attribute__((visibility ("default"))) ;
extern time_t mktime(struct tm*) __attribute__((visibility ("default")));

extern struct tm* localtime(const time_t*) __attribute__((visibility ("default")));
extern struct tm* localtime_r(const time_t*, struct tm*) __attribute__((visibility ("default")));

extern struct tm* gmtime(const time_t*) __attribute__((visibility ("default")));
extern struct tm* gmtime_r(const time_t*, struct tm*) __attribute__((visibility ("default")));

extern char* strptime(const char*, const char*, struct tm*) __attribute__((visibility ("default")));
extern size_t strftime(char*, size_t, const char*, const struct tm*) __attribute__((visibility ("default")));
extern size_t strftime_l(char *, size_t, const char *, const struct tm *, locale_t) __attribute__((visibility ("default")));

extern char* ctime(const time_t*) __attribute__((visibility ("default")));
extern char* ctime_r(const time_t*, char*) __attribute__((visibility ("default")));

extern void tzset(void) __attribute__((visibility ("default")));

extern clock_t clock(void) __attribute__((visibility ("default")));

extern int clock_getres(clockid_t, struct timespec*) __attribute__((visibility ("default")));
extern int clock_gettime(clockid_t, struct timespec*) __attribute__((visibility ("default")));
extern int clock_nanosleep(clockid_t, int, const struct timespec*, struct timespec*) __attribute__((visibility ("default")));
extern int clock_settime(clockid_t, const struct timespec*) __attribute__((visibility ("default")));

extern int timer_create(int, struct sigevent*, timer_t*) __attribute__((visibility ("default")));
extern int timer_delete(timer_t) __attribute__((visibility ("default")));
extern int timer_settime(timer_t, int, const struct itimerspec*, struct itimerspec*) __attribute__((visibility ("default")));
extern int timer_gettime(timer_t, struct itimerspec*) __attribute__((visibility ("default")));
extern int timer_getoverrun(timer_t) __attribute__((visibility ("default")));


extern time_t timelocal(struct tm*) __attribute__((visibility ("default")));
extern time_t timegm(struct tm*) __attribute__((visibility ("default")));

}
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/time.h" 2 3
# 37 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/wchar.h" 2 3

# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/machine/wchar_limits.h" 1 3
# 39 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/wchar.h" 2 3

extern "C" {

typedef unsigned int wint_t;
typedef struct {
  uint8_t __seq[4];

  char __reserved[4];

} mbstate_t;

enum {
    WC_TYPE_INVALID = 0,
    WC_TYPE_ALNUM,
    WC_TYPE_ALPHA,
    WC_TYPE_BLANK,
    WC_TYPE_CNTRL,
    WC_TYPE_DIGIT,
    WC_TYPE_GRAPH,
    WC_TYPE_LOWER,
    WC_TYPE_PRINT,
    WC_TYPE_PUNCT,
    WC_TYPE_SPACE,
    WC_TYPE_UPPER,
    WC_TYPE_XDIGIT,
    WC_TYPE_MAX
};

typedef long wctype_t;



extern wint_t btowc(int);
extern int fwprintf(FILE *, const wchar_t *, ...);
extern int fwscanf(FILE *, const wchar_t *, ...);
extern int iswalnum(wint_t);
extern int iswalpha(wint_t);
extern int iswblank(wint_t);
extern int iswcntrl(wint_t);
extern int iswdigit(wint_t);
extern int iswgraph(wint_t);
extern int iswlower(wint_t);
extern int iswprint(wint_t);
extern int iswpunct(wint_t);
extern int iswspace(wint_t);
extern int iswupper(wint_t);
extern int iswxdigit(wint_t);
extern int iswctype(wint_t, wctype_t);
extern wint_t fgetwc(FILE *);
extern wchar_t *fgetws(wchar_t *, int, FILE *);
extern wint_t fputwc(wchar_t, FILE *);
extern int fputws(const wchar_t *, FILE *);
extern int fwide(FILE *, int);
extern wint_t getwc(FILE *);
extern wint_t getwchar(void);
extern int mbsinit(const mbstate_t *);
extern size_t mbrlen(const char *, size_t, mbstate_t *);
extern size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
extern size_t mbsrtowcs(wchar_t*, const char**, size_t, mbstate_t*);
extern size_t mbsnrtowcs(wchar_t*, const char**, size_t, size_t, mbstate_t*);
extern size_t mbstowcs(wchar_t *, const char *, size_t);
extern wint_t putwc(wchar_t, FILE *);
extern wint_t putwchar(wchar_t);
extern int swprintf(wchar_t *, size_t, const wchar_t *, ...);
extern int swscanf(const wchar_t *, const wchar_t *, ...);
extern wint_t towlower(wint_t);
extern wint_t towupper(wint_t);
extern wint_t ungetwc(wint_t, FILE *);
extern int vfwprintf(FILE*, const wchar_t*, va_list);
extern int vfwscanf(FILE*, const wchar_t*, va_list);
extern int vswprintf(wchar_t*, size_t, const wchar_t*, va_list);
extern int vswscanf(const wchar_t*, const wchar_t*, va_list);
extern int vwprintf(const wchar_t*, va_list);
extern int vwscanf(const wchar_t*, va_list);
extern size_t wcrtomb(char *, wchar_t, mbstate_t *);
extern int wcscasecmp(const wchar_t *, const wchar_t *);
extern wchar_t *wcscat(wchar_t *, const wchar_t *);
extern wchar_t *wcschr(const wchar_t *, wchar_t);
extern int wcscmp(const wchar_t *, const wchar_t *);
extern int wcscoll(const wchar_t *, const wchar_t *);
extern wchar_t *wcscpy(wchar_t *, const wchar_t *);
extern size_t wcscspn(const wchar_t *, const wchar_t *);
extern size_t wcsftime(wchar_t *, size_t, const wchar_t *, const struct tm *) __attribute__((visibility ("default")));
extern size_t wcslen(const wchar_t *);
extern int wcsncasecmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
extern int wcsncmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
extern size_t wcsnrtombs(char*, const wchar_t**, size_t, size_t, mbstate_t*);
extern wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
extern wchar_t *wcsrchr(const wchar_t *, wchar_t);
extern size_t wcsrtombs(char*, const wchar_t**, size_t, mbstate_t*);
extern size_t wcsspn(const wchar_t *, const wchar_t *);
extern wchar_t *wcsstr(const wchar_t *, const wchar_t *);
extern double wcstod(const wchar_t*, wchar_t**) ;
extern float wcstof(const wchar_t*, wchar_t**) ;
extern wchar_t* wcstok(wchar_t*, const wchar_t*, wchar_t**);
extern long wcstol(const wchar_t*, wchar_t**, int);
extern long long wcstoll(const wchar_t*, wchar_t**, int);
extern long double wcstold(const wchar_t*, wchar_t**) ;
extern unsigned long wcstoul(const wchar_t*, wchar_t**, int);
extern unsigned long long wcstoull(const wchar_t*, wchar_t**, int);
extern int wcswidth(const wchar_t *, size_t);
extern size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
extern int wctob(wint_t);
extern wctype_t wctype(const char *);
extern int wcwidth(wchar_t);
extern wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
extern int wmemcmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemset(wchar_t *, wchar_t, size_t);
extern int wprintf(const wchar_t *, ...);
extern int wscanf(const wchar_t *, ...);

extern long long wcstoll_l(const wchar_t *, wchar_t **, int, locale_t);
extern unsigned long long wcstoull_l(const wchar_t *, wchar_t **, int, locale_t);
extern long double wcstold_l(const wchar_t *, wchar_t **, locale_t ) ;

extern int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
extern size_t wcsxfrm_l(wchar_t *, const wchar_t *, size_t, locale_t);

extern size_t wcslcat(wchar_t*, const wchar_t*, size_t);
extern size_t wcslcpy(wchar_t*, const wchar_t*, size_t);

typedef void *wctrans_t;
extern wint_t towctrans(wint_t, wctrans_t);
extern wctrans_t wctrans(const char*);


wchar_t* wcsdup(const wchar_t*);
size_t wcsnlen(const wchar_t*, size_t);


}
# 67 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/wchar.h" 2 3
# 91 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iosfwd" 2 3


       
# 94 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iosfwd" 3


namespace std { namespace __ndk1 {

class __attribute__ ((__visibility__("default"))) ios_base;

template<class _CharT> struct __attribute__ ((__visibility__("default"))) char_traits;
template<class _Tp> class __attribute__ ((__visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__ ((__visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class __attribute__ ((__visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;


typedef long long streamoff;

template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__ ((__visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char> > string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;

} }
# 336 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iterator" 2 3
# 348 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iterator" 3
       
# 349 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iterator" 3


namespace std { namespace __ndk1 {

struct __attribute__ ((__visibility__("default"))) input_iterator_tag {};
struct __attribute__ ((__visibility__("default"))) output_iterator_tag {};
struct __attribute__ ((__visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__ ((__visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__ ((__visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Tp>
struct __has_iterator_category
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::iterator_category* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true>
{
    typedef typename _Iter::difference_type difference_type;
    typedef typename _Iter::value_type value_type;
    typedef typename _Iter::pointer pointer;
    typedef typename _Iter::reference reference;
    typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl
      <
        _Iter,
        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value
      >
{};






template <class _Iter>
struct __attribute__ ((__visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

template<class _Tp>
struct __attribute__ ((__visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef typename remove_const<_Tp>::type value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>
{};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};

template <class _Tp>
struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};

template <class _Tp>
struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};

template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__ ((__visibility__("default"))) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)
{
    for (; __n > 0; --__n)
        ++__i;
}

template <class _BiDirIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_BiDirIter& __i,
             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)
{
    if (__n >= 0)
        for (; __n > 0; --__n)
            ++__i;
    else
        for (; __n < 0; ++__n)
            --__i;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void __advance(_RandIter& __i,
             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)
{
   __i += __n;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void advance(_InputIter& __i,
             typename iterator_traits<_InputIter>::difference_type __n)
{
    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}

template <class _RandIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}

template <class _InputIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}

template <class _ForwardIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIter
next(_ForwardIter __x,
     typename iterator_traits<_ForwardIter>::difference_type __n = 1,
     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)
{
    std::__ndk1::advance(__x, __n);
    return __x;
}

template <class _BidiretionalIter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidiretionalIter
prev(_BidiretionalIter __x,
     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,
     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)
{
    std::__ndk1::advance(__x, -__n);
    return __x;
}

template <class _Iter>
class __attribute__ ((__visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
private:
    mutable _Iter __t;
protected:
    _Iter current;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<_Iter>::difference_type difference_type;
    typedef typename iterator_traits<_Iter>::reference reference;
    typedef typename iterator_traits<_Iter>::pointer pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator() : current() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator(const reverse_iterator<_Up>& __u)
        : __t(__u.base()), current(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return current;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {return std::__ndk1::addressof(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator++() {--current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator++(int)
        {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator--() {++current; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator--(int)
        {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator+ (difference_type __n) const
        {return reverse_iterator(current - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator+=(difference_type __n)
        {current -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator operator- (difference_type __n) const
        {return reverse_iterator(current + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reverse_iterator& operator-=(difference_type __n)
        {current += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
        {return current[-__n-1];}
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename reverse_iterator<_Iter1>::difference_type
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __y.base() - __x.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}


template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
{
    return reverse_iterator<_Iter>(__i);
}


template <class _Container>
class __attribute__ ((__visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      back_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit back_insert_iterator(_Container& __x) : container(std::__ndk1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_back(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_back(std::__ndk1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) back_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      front_insert_iterator<_Container>&>
{
protected:
    _Container* container;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit front_insert_iterator(_Container& __x) : container(std::__ndk1::addressof(__x)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator=(const typename _Container::value_type& __value_)
        {container->push_front(__value_); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator=(typename _Container::value_type&& __value_)
        {container->push_front(std::__ndk1::move(__value_)); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) front_insert_iterator operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__ ((__visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag,
                      void,
                      void,
                      void,
                      insert_iterator<_Container>&>
{
protected:
    _Container* container;
    typename _Container::iterator iter;
public:
    typedef _Container container_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator(_Container& __x, typename _Container::iterator __i)
        : container(std::__ndk1::addressof(__x)), iter(__i) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator=(const typename _Container::value_type& __value_)
        {iter = container->insert(iter, __value_); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator=(typename _Container::value_type&& __value_)
        {iter = container->insert(iter, std::__ndk1::move(__value_)); ++iter; return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) insert_iterator& operator++(int) {return *this;}
};

template <class _Container>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
insert_iterator<_Container>
inserter(_Container& __x, typename _Container::iterator __i)
{
    return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__ ((__visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator() : __in_stream_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator(istream_type& __s) : __in_stream_(&__s)
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp& operator*() const {return __value_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const _Tp* operator->() const {return &(operator*());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const istream_iterator& __x, const istream_iterator& __y)
        {return __x.__in_stream_ == __y.__in_stream_;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__ ((__visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s)
        : __out_stream_(&__s), __delim_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type& __s, const _CharT* __delimiter)
        : __out_stream_(&__s), __delim_(__delimiter) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator=(const _Tp& __value_)
        {
            *__out_stream_ << __value_;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostream_iterator& operator++(int) {return *this;}
};

template<class _CharT, class _Traits>
class __attribute__ ((__visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;

    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const {return __keep_;}
    };

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = 0;
        return __sbuf_ == 0;
    }
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr istreambuf_iterator() throw() : __sbuf_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(istream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(const __proxy& __p) throw()
        : __sbuf_(__p.__sbuf_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) char_type* operator->() const {return nullptr;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
};

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}

template <class _CharT, class _Traits>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return !__a.equal(__b);}

template <class _CharT, class _Traits>
class __attribute__ ((__visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_ostream<_CharT,_Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(ostream_type& __s) throw()
        : __sbuf_(__s.rdbuf()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(streambuf_type* __s) throw()
        : __sbuf_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = 0;
            return *this;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool failed() const throw() {return __sbuf_ == 0;}





    template <class _Ch, class _Tr>
    friend
    __attribute__ ((__visibility__("hidden")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);

};

template <class _Iter>
class __attribute__ ((__visibility__("default"))) move_iterator
{
private:
    _Iter __i;
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;

    typedef value_type&& reference;




    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator() : __i() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit move_iterator(_Iter __x) : __i(__x) {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator(const move_iterator<_Up>& __u)
        : __i(__u.base()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Iter base() const {return __i;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const {
      return static_cast<reference>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const {
      typename iterator_traits<iterator_type>::reference __ref = *__i;
      return &__ref;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator++() {++__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator++(int)
        {move_iterator __tmp(*this); ++__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator--() {--__i; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator--(int)
        {move_iterator __tmp(*this); --__i; return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator+ (difference_type __n) const
        {return move_iterator(__i + __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator+=(difference_type __n)
        {__i += __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator operator- (difference_type __n) const
        {return move_iterator(__i - __n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) move_iterator& operator-=(difference_type __n)
        {__i -= __n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const
    {
      return static_cast<reference>(__i[__n]);
    }
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename move_iterator<_Iter1>::difference_type
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
{
    return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter1, class _Iter2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

template <class _Iter>
__attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) throw();

template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op> _Op __attribute__ ((__visibility__("hidden"), __always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2> _B2 __attribute__ ((__visibility__("hidden"), __always_inline__)) move_backward(_B1, _B1, _B2);

template <class _Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*>);

template <class _Tp, class _Alloc> class __attribute__ ((__visibility__("default"))) vector;

template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
private:
    iterator_type __i;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter() throw()

                : __i{}

    {



    }
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(const __wrap_iter<_Up>& __u,
        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) throw()
        : __i(__u.base())
    {



    }
# 1163 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iterator" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator*() const throw()
    {




        return *__i;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw()
    {




        return (pointer)&reinterpret_cast<const volatile char&>(*__i);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator++() throw()
    {




        ++__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator++(int) throw()
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator--() throw()
    {




        --__i;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator--(int) throw()
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator+ (difference_type __n) const throw()
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator+=(difference_type __n) throw()
    {




        __i += __n;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter operator- (difference_type __n) const throw()
        {return *this + (-__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter& operator-=(difference_type __n) throw()
        {*this += -__n; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const throw()
    {




        return __i[__n];
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) iterator_type base() const throw() {return __i;}

private:






    __attribute__ ((__visibility__("hidden"), __always_inline__)) __wrap_iter(iterator_type __x) throw() : __i(__x) {}


    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class vector;

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    bool
    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1, class _Iter2>
    friend
    typename __wrap_iter<_Iter1>::difference_type
    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) throw();

    template <class _Iter1>
    friend
    __wrap_iter<_Iter1>
    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) throw();

    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);

    template <class _Tp>
    friend
    typename enable_if
    <
        is_trivially_copy_assignable<_Tp>::value,
        _Tp*
    >::type
    __unwrap_iter(__wrap_iter<_Tp*>);
};

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x == __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return __y < __x;
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__x < __y);
}

template <class _Iter1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw()
{
    return !(__y < __x);
}

template <class _Iter1, class _Iter2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __wrap_iter<_Iter1>::difference_type
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()
{




    return __x.base() - __y.base();
}

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) throw()
{
    __x += __n;
    return __x;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}

template <class _Tp, size_t _Np>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}
# 1543 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/iterator" 3
template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
begin(_Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
begin(const _Cp& __c)
{
    return __c.begin();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::iterator
end(_Cp& __c)
{
    return __c.end();
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename _Cp::const_iterator
end(const _Cp& __c)
{
    return __c.end();
}



} }
# 605 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/tuple" 1 3
# 133 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/tuple" 3
       
# 134 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/tuple" 3


namespace std { namespace __ndk1 {





template <class ..._Tp>
class __attribute__ ((__visibility__("default"))) tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};



template <size_t _Ip, class ..._Tp>
class __attribute__ ((__visibility__("default"))) tuple_element<_Ip, tuple<_Tp...> >
{
public:
    typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};


template <size_t _Ip, class ..._Tp>
using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;




template <size_t _Ip, class _Hp, bool=is_empty<_Hp>::value

                                 && !__is_final(_Hp)

         >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
   
{
    swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp value;

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr __tuple_leaf()
             : value()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : value()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : value(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : value(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}

    template <class _Tp,
              class = typename enable_if<is_constructible<_Hp, _Tp>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit __tuple_leaf(_Tp&& __t)
            : value(std::__ndk1::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value ||
                       (is_lvalue_reference<_Hp>::value &&
                        (is_lvalue_reference<_Tp>::value ||
                         is_same<typename remove_reference<_Tp>::type,
                                 reference_wrapper<
                                    typename remove_reference<_Hp>::type
                                 >
                                >::value)) ||
                        (is_rvalue_reference<_Hp>::value &&
                         !is_lvalue_reference<_Tp>::value),
       "Attempted to construct a reference element in a tuple with an rvalue");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : value(std::__ndk1::forward<_Tp>(__t))
        {static_assert(!is_lvalue_reference<_Hp>::value ||
                       (is_lvalue_reference<_Hp>::value &&
                        (is_lvalue_reference<_Tp>::value ||
                         is_same<typename remove_reference<_Tp>::type,
                                 reference_wrapper<
                                    typename remove_reference<_Hp>::type
                                 >
                                >::value)),
       "Attempted to construct a reference element in a tuple with an rvalue");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : value(allocator_arg_t(), __a, std::__ndk1::forward<_Tp>(__t))
        {static_assert(!is_lvalue_reference<_Hp>::value ||
                       (is_lvalue_reference<_Hp>::value &&
                        (is_lvalue_reference<_Tp>::value ||
                         is_same<typename remove_reference<_Tp>::type,
                                 reference_wrapper<
                                    typename remove_reference<_Hp>::type
                                 >
                                >::value)),
       "Attempted to construct a reference element in a tuple with an rvalue");}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : value(std::__ndk1::forward<_Tp>(__t), __a)
        {static_assert(!is_lvalue_reference<_Hp>::value ||
                       (is_lvalue_reference<_Hp>::value &&
                        (is_lvalue_reference<_Tp>::value ||
                         is_same<typename remove_reference<_Tp>::type,
                                 reference_wrapper<
                                    typename remove_reference<_Hp>::type
                                 >
                                >::value)),
       "Attempted to construct a reference element in a tuple with an rvalue");}

    __tuple_leaf(const __tuple_leaf& __t) = default;
    __tuple_leaf(__tuple_leaf&& __t) = default;

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf&
        operator=(_Tp&& __t)
        {
            value = std::__ndk1::forward<_Tp>(__t);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int swap(__tuple_leaf& __t)
    {
        std::__ndk1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr _Hp& get() throw() {return value;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr const _Hp& get() const throw() {return value;}
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{

    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr __tuple_leaf()
             {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}

    template <class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}

    template <class _Tp,
              class = typename enable_if<is_constructible<_Hp, _Tp>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit __tuple_leaf(_Tp&& __t)
            : _Hp(std::__ndk1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::__ndk1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::__ndk1::forward<_Tp>(__t)) {}

    template <class _Tp, class _Alloc>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::__ndk1::forward<_Tp>(__t), __a) {}

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_leaf&
        operator=(_Tp&& __t)
        {
            _Hp::operator=(std::__ndk1::forward<_Tp>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    int
    swap(__tuple_leaf& __t)
    {
        std::__ndk1::swap(*this, __t);
        return 0;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr _Hp& get() throw() {return static_cast<_Hp&>(*this);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr const _Hp& get() const throw() {return static_cast<const _Hp&>(*this);}
};

template <class ..._Tp>
__attribute__ ((__visibility__("hidden"), __always_inline__))
void __swallow(_Tp&&...) throw() {}

template <bool ...> struct __all;

template <>
struct __all<>
{
    static const bool value = true;
};

template <bool _B0, bool ... _Bp>
struct __all<_B0, _Bp...>
{
    static const bool value = _B0 && __all<_Bp...>::value;
};



template<class _Indx, class ..._Tp> struct __tuple_impl;

template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __tuple_impl()
        {}

    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                    
                                                                                                 :
            __tuple_leaf<_Uf, _Tf>(std::__ndk1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}

    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::__ndk1::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        __tuple_impl(_Tuple&& __t)

            : __tuple_leaf<_Indx, _Tp>(std::__ndk1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__ndk1::get<_Indx>(__t)))...
            {}

    template <class _Alloc, class _Tuple,
              class = typename enable_if
                      <
                         __tuple_convertible<_Tuple, tuple<_Tp...> >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::__ndk1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__ndk1::get<_Indx>(__t)))...
            {}

    template <class _Tuple>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            __tuple_assignable<_Tuple, tuple<_Tp...> >::value,
            __tuple_impl&
        >::type
        operator=(_Tuple&& __t)

        {
            __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__ndk1::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::__ndk1::get<_Indx>(__t)))...);
            return *this;
        }

    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tuple_impl&
    operator=(const __tuple_impl& __t)
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __tuple_impl&
    operator=(__tuple_impl&& __t)
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__ndk1::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(__tuple_impl& __t)
       
    {
        __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};

template <class ..._Tp>
class __attribute__ ((__visibility__("default"))) tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> base;

    base base_;

    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) throw();
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) throw();
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) throw();
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr tuple()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    explicit tuple(const _Tp& ... __t)
        : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}

    template <class ..._Up,
              typename enable_if
                      <
                         sizeof...(_Up) <= sizeof...(_Tp) &&
                         __tuple_convertible
                         <
                            tuple<_Up...>,
                            typename __make_tuple_types<tuple,
                                     sizeof...(_Up) < sizeof...(_Tp) ?
                                        sizeof...(_Up) :
                                        sizeof...(_Tp)>::type
                         >::value,
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        tuple(_Up&&... __u)
           
# 550 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/tuple" 3
            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__ndk1::forward<_Up>(__u)...) {}

    template <class ..._Up,
              typename enable_if
                      <
                         sizeof...(_Up) <= sizeof...(_Tp) &&
                         __tuple_constructible
                         <
                            tuple<_Up...>,
                            typename __make_tuple_types<tuple,
                                     sizeof...(_Up) < sizeof...(_Tp) ?
                                        sizeof...(_Up) :
                                        sizeof...(_Tp)>::type
                         >::value &&
                         !__tuple_convertible
                         <
                            tuple<_Up...>,
                            typename __make_tuple_types<tuple,
                                     sizeof...(_Up) < sizeof...(_Tp) ?
                                        sizeof...(_Up) :
                                        sizeof...(_Tp)>::type
                         >::value,
                         bool
                      >::type =false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit
        tuple(_Up&&... __u)
           
# 591 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/tuple" 3
            : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__ndk1::forward<_Up>(__u)...) {}

    template <class _Alloc, class ..._Up,
              class = typename enable_if
                      <
                         sizeof...(_Up) <= sizeof...(_Tp) &&
                         __tuple_convertible
                         <
                            tuple<_Up...>,
                            typename __make_tuple_types<tuple,
                                     sizeof...(_Up) < sizeof...(_Tp) ?
                                        sizeof...(_Up) :
                                        sizeof...(_Tp)>::type
                         >::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
            : base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::__ndk1::forward<_Up>(__u)...) {}

    template <class _Tuple,
              typename enable_if
                      <
                         __tuple_convertible<_Tuple, tuple>::value,
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        tuple(_Tuple&& __t)
            : base_(std::__ndk1::forward<_Tuple>(__t)) {}

    template <class _Tuple,
              typename enable_if
                      <
                         __tuple_constructible<_Tuple, tuple>::value &&
                         !__tuple_convertible<_Tuple, tuple>::value,
                         bool
                      >::type = false
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
        explicit
        tuple(_Tuple&& __t)
            : base_(std::__ndk1::forward<_Tuple>(__t)) {}

    template <class _Alloc, class _Tuple,
              class = typename enable_if
                      <
                         __tuple_convertible<_Tuple, tuple>::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : base_(allocator_arg_t(), __a, std::__ndk1::forward<_Tuple>(__t)) {}

    template <class _Tuple,
              class = typename enable_if
                      <
                         __tuple_assignable<_Tuple, tuple>::value
                      >::type
             >
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple&
        operator=(_Tuple&& __t)
        {
            base_.operator=(std::__ndk1::forward<_Tuple>(__t));
            return *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(tuple& __t)
        {base_.swap(__t.base_);}
};

template <>
class __attribute__ ((__visibility__("default"))) tuple<>
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr tuple() throw() {}
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc&) throw() {}
    template <class _Alloc>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc&, const tuple&) throw() {}
    template <class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(array<_Up, 0>) throw() {}
    template <class _Alloc, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(tuple&) throw() {}
};

template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __all<__is_swappable<_Tp>::value...>::value,
    void
>::type
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                
    {__t.swap(__u);}



template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) throw()
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) throw()
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.base_).get();
}

template <size_t _Ip, class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) throw()
{
    typedef typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.base_).get());
}



template <typename _T1, size_t _Idx, typename... _Args>
struct __find_exactly_one_t_helper;


template <typename _T1, size_t _Idx, typename... _Args>
struct __find_exactly_one_t_checker {
    static constexpr size_t value = _Idx;

    static_assert ( __find_exactly_one_t_helper<_T1, 0, _Args...>::value == -1, "type can only occur once in type list" );
    };


template <typename _T1, size_t _Idx>
struct __find_exactly_one_t_helper <_T1, _Idx> {
    static constexpr size_t value = -1;
    };

template <typename _T1, size_t _Idx, typename _Head, typename... _Args>
struct __find_exactly_one_t_helper <_T1, _Idx, _Head, _Args...> {
    static constexpr size_t value =
        std::conditional<
            std::is_same<_T1, _Head>::value,
            __find_exactly_one_t_checker<_T1, _Idx, _Args...>,
            __find_exactly_one_t_helper <_T1, _Idx+1, _Args...>
        >::type::value;
    };

template <typename _T1, typename... _Args>
struct __find_exactly_one_t {
    static constexpr size_t value = __find_exactly_one_t_helper<_T1, 0, _Args...>::value;
    static_assert ( value != -1, "type not found in type list" );
    };

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1& get(tuple<_Args...>& __tup) noexcept
{
    return std::__ndk1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
{
    return std::__ndk1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
{
    return std::__ndk1::get<__find_exactly_one_t<_T1, _Args...>::value>(std::__ndk1::move(__tup));
}





template <class ..._Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
tuple<_Tp&...>
tie(_Tp&... __t) throw()
{
    return tuple<_Tp&...>(__t...);
}

template <class _Up>
struct __ignore_t
{
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        const __ignore_t& operator=(_Tp&&) const {return *this;}
};

namespace { const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>(); }

template <class _Tp> class __attribute__ ((__visibility__("default"))) reference_wrapper;

template <class _Tp>
struct __make_tuple_return_impl
{
    typedef _Tp type;
};

template <class _Tp>
struct __make_tuple_return_impl<reference_wrapper<_Tp> >
{
    typedef _Tp& type;
};

template <class _Tp>
struct __make_tuple_return
{
    typedef typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;
};

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
tuple<typename __make_tuple_return<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __make_tuple_return<_Tp>::type...>(std::__ndk1::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) throw()
{
    return tuple<_Tp&&...>(std::__ndk1::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && get<_Ip-1>(__x) == get<_Ip-1>(__y);
    }
};

template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_less<_Ip-1>()(__x, __y) ||
             (!__tuple_less<_Ip-1>()(__y, __x) && get<_Ip-1>(__x) < get<_Ip-1>(__y));
    }
};

template <>
struct __tuple_less<0>
{
    template <class _Tp, class _Up>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return false;
    }
};

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return __y < __x;
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__x < __y);
}

template <class ..._Tp, class ..._Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return !(__y < __x);
}



template <class _Tp, class _Up> struct __tuple_cat_type;

template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};

template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
    typedef typename __tuple_cat_type<tuple<_Types...>,
            typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type>::type
                                                                           type;
};

template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<typename remove_reference<_Tuple0>::type>::type
                 >::type,
                 __tuple_like<typename remove_reference<_Tuple1>::type>::value,
                 _Tuple1, _Tuples...>
{
};

template <class ..._Tuples> struct __tuple_cat_return;

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like<typename remove_reference<_Tuple0>::type>::value, _Tuple0,
                                                                     _Tuples...>
{
};

template <>
struct __tuple_cat_return<>
{
    typedef tuple<> type;
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
tuple<>
tuple_cat()
{
    return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;

template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};

template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  typename remove_reference<_Tuple0>::type>::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<typename
                                 remove_reference<_Tuple1>::type>::value>::type,
         _Tuple1, _Tuples...>
{
};

template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<typename remove_reference<_Tuple0>::type>::value
               >::type, _Tuple0, _Tuples...>
{
};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        return forward_as_tuple(std::__ndk1::forward<_Types>(get<_I0>(__t))...,
                                      get<_J0>(std::__ndk1::forward<_Tuple0>(__t0))...);
    }

    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        typedef typename remove_reference<_Tuple0>::type _T0;
        typedef typename remove_reference<_Tuple1>::type _T1;
        return __tuple_cat<
           tuple<_Types..., typename __apply_cv<_Tuple0, typename tuple_element<_J0, _T0>::type>::type&&...>,
           typename __make_tuple_indices<sizeof ...(_Types) + tuple_size<_T0>::value>::type,
           typename __make_tuple_indices<tuple_size<_T1>::value>::type>()
                           (forward_as_tuple(
                              std::__ndk1::forward<_Types>(get<_I0>(__t))...,
                              get<_J0>(std::__ndk1::forward<_Tuple0>(__t0))...
                            ),
                            std::__ndk1::forward<_Tuple1>(__t1),
                            std::__ndk1::forward<_Tuples>(__tpls)...);
    }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef typename remove_reference<_Tuple0>::type _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::__ndk1::forward<_Tuple0>(__t0),
                                            std::__ndk1::forward<_Tuples>(__tpls)...);
}

template <class ..._Tp, class _Alloc>
struct __attribute__ ((__visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::__ndk1::forward<_Args1>(get<_I1>( __first_args))...),
      second(std::__ndk1::forward<_Args2>(get<_I2>(__second_args))...)
{
}



} }
# 608 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstring" 1 3
# 61 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstring" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/string.h" 1 3
# 31 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/string.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/string.h" 1 3
# 32 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/string.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 1 3 4
# 33 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/string.h" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/malloc.h" 1 3
# 26 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/malloc.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include/stddef.h" 1 3 4
# 27 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/malloc.h" 2 3

extern "C" {

extern void* malloc(size_t byte_count) __attribute__((malloc)) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
extern void* calloc(size_t item_count, size_t item_size) __attribute__((malloc)) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2)));
extern void* realloc(void* p, size_t byte_count) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
extern void free(void* p);

extern void* memalign(size_t alignment, size_t byte_count) __attribute__((malloc)) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
extern size_t malloc_usable_size(const void* p);



struct mallinfo {
  size_t arena;
  size_t ordblks;
  size_t smblks;
  size_t hblks;
  size_t hblkhd;
  size_t usmblks;
  size_t fsmblks;
  size_t uordblks;
  size_t fordblks;
  size_t keepcost;
};


extern struct mallinfo mallinfo(void);

}
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/string.h" 2 3


extern "C" {

extern void* memccpy(void* __restrict, const void* __restrict, int, size_t);
extern void* memchr(const void *, int, size_t) __attribute__((pure));
extern void* memrchr(const void *, int, size_t) __attribute__((pure));
extern int memcmp(const void *, const void *, size_t) __attribute__((pure));
extern void* memcpy(void* __restrict, const void* __restrict, size_t);
extern void* memmove(void *, const void *, size_t);
extern void* memset(void *, int, size_t);
extern void* memmem(const void *, size_t, const void *, size_t) __attribute__((pure));

extern char* strchr(const char *, int) __attribute__((pure));
extern char* __strchr_chk(const char *, int, size_t);

extern char* strrchr(const char *, int) __attribute__((pure));
extern char* __strrchr_chk(const char *, int, size_t);

extern size_t strlen(const char *) __attribute__((pure));
extern size_t __strlen_chk(const char *, size_t);
extern int strcmp(const char *, const char *) __attribute__((pure));
extern char* stpcpy(char* __restrict, const char* __restrict);
extern char* strcpy(char* __restrict, const char* __restrict);
extern char* strcat(char* __restrict, const char* __restrict);

extern int strcasecmp(const char *, const char *) __attribute__((pure));
extern int strncasecmp(const char *, const char *, size_t) __attribute__((pure));
extern char* strdup(const char *);

extern char* strstr(const char *, const char *) __attribute__((pure));
extern char* strcasestr(const char *haystack, const char *needle) __attribute__((pure));
extern char* strtok(char* __restrict, const char* __restrict);
extern char* strtok_r(char* __restrict, const char* __restrict, char** __restrict);

extern char* strerror(int);
extern int strerror_r(int errnum, char *buf, size_t n);

extern size_t strnlen(const char *, size_t) __attribute__((pure));
extern char* strncat(char* __restrict, const char* __restrict, size_t);
extern char* strndup(const char *, size_t);
extern int strncmp(const char *, const char *, size_t) __attribute__((pure));
extern char* stpncpy(char* __restrict, const char* __restrict, size_t);
extern char* strncpy(char* __restrict, const char* __restrict, size_t);

extern size_t strlcat(char* __restrict, const char* __restrict, size_t);
extern size_t strlcpy(char* __restrict, const char* __restrict, size_t);

extern size_t strcspn(const char *, const char *) __attribute__((pure));
extern char* strpbrk(const char *, const char *) __attribute__((pure));
extern char* strsep(char** __restrict, const char* __restrict);
extern size_t strspn(const char *, const char *);

extern char* strsignal(int sig);

extern int strcoll(const char *, const char *) __attribute__((pure));
extern size_t strxfrm(char* __restrict, const char* __restrict, size_t);

extern int strcoll_l(const char *, const char *, locale_t) __attribute__((pure));
extern size_t strxfrm_l(char* __restrict, const char* __restrict, size_t, locale_t);
# 292 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/string.h" 3
}
# 32 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/string.h" 2 3
# 62 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstring" 2 3


       
# 65 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cstring" 3


namespace std { namespace __ndk1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;

using ::memchr;

using ::strchr;

using ::strcspn;

using ::strpbrk;

using ::strrchr;

using ::strspn;

using ::strstr;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strchr( char* __s, int __c) {return ::strchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strpbrk( char* __s1, const char* __s2) {return ::strpbrk(__s1, __s2);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strrchr( char* __s, int __c) {return ::strrchr(__s, __c);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) void* memchr( void* __s, int __c, size_t __n) {return ::memchr(__s, __c, __n);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) char* strstr( char* __s1, const char* __s2) {return ::strstr(__s1, __s2);}


using ::strtok;
using ::memset;
using ::strerror;
using ::strlen;

} }
# 609 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3

# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cassert" 1 3
# 21 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cassert" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/assert.h" 1 3
# 62 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/assert.h" 3
extern "C" {
 void __assert(const char *, int, const char *) __attribute__((__noreturn__));
 void __assert2(const char *, int, const char *, const char *) __attribute__((__noreturn__));
}
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cassert" 2 3


       
# 25 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cassert" 3
# 611 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3



# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/atomic" 1 3
# 533 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/atomic" 3
       
# 534 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/atomic" 3


namespace std { namespace __ndk1 {





typedef enum memory_order
{
    memory_order_relaxed, memory_order_consume, memory_order_acquire,
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
} memory_order;



namespace __gcc_atomic {
template <typename T>
struct __gcc_atomic_t {
  __gcc_atomic_t() throw() {}
  explicit __gcc_atomic_t(T value) throw() : __a_value(value) {}
  T __a_value;
};


template <typename T> T __create();

template <typename __Tp, typename __Td>
typename enable_if<sizeof(__Tp()->__a_value = __create<__Td>()), char>::type
    __test_atomic_assignable(int);
template <typename T, typename U>
__two __test_atomic_assignable(...);

template <typename __Tp, typename __Td>
struct __can_assign {
  static const bool value =
      sizeof(__test_atomic_assignable<__Tp, __Td>(1)) == sizeof(char);
};

static inline int __to_gcc_order(memory_order __order) {
  switch (__order) {
    case memory_order_relaxed:
      return 0;
    case memory_order_consume:
      return 1;
    case memory_order_acquire:
      return 2;
    case memory_order_release:
      return 3;
    case memory_order_acq_rel:
      return 4;
    case memory_order_seq_cst:
      return 5;
  }
}

}

template <typename _Tp>
static inline
typename enable_if<
    __gcc_atomic::__can_assign<volatile __gcc_atomic::__gcc_atomic_t<_Tp>*, _Tp>::value>::type
__c11_atomic_init(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp __val) {
  __a->__a_value = __val;
}

template <typename _Tp>
static inline
typename enable_if<
    !__gcc_atomic::__can_assign<volatile __gcc_atomic::__gcc_atomic_t<_Tp>*, _Tp>::value &&
     __gcc_atomic::__can_assign< __gcc_atomic::__gcc_atomic_t<_Tp>*, _Tp>::value>::type
__c11_atomic_init(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp __val) {



  volatile char* to = reinterpret_cast<volatile char*>(&__a->__a_value);
  volatile char* end = to + sizeof(_Tp);
  char* from = reinterpret_cast<char*>(&__val);
  while (to != end) {
    *to++ = *from++;
  }
}

template <typename _Tp>
static inline void __c11_atomic_init(__gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp __val) {
  __a->__a_value = __val;
}

static inline void __c11_atomic_thread_fence(memory_order __order) {
  __atomic_thread_fence(__gcc_atomic::__to_gcc_order(__order));
}

static inline void __c11_atomic_signal_fence(memory_order __order) {
  __atomic_signal_fence(__gcc_atomic::__to_gcc_order(__order));
}

static inline bool __c11_atomic_is_lock_free(size_t __size) {
  return __atomic_is_lock_free(__size, 0);
}

template <typename _Tp>
static inline void __c11_atomic_store(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp __val,
                                      memory_order __order) {
  return __atomic_store(&__a->__a_value, &__val,
                        __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline void __c11_atomic_store(__gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp __val,
                                      memory_order __order) {
  return __atomic_store(&__a->__a_value, &__val,
                        __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_load(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a,
                                    memory_order __order) {
  _Tp __ret;
  __atomic_load(&__a->__a_value, &__ret,
                __gcc_atomic::__to_gcc_order(__order));
  return __ret;
}

template <typename _Tp>
static inline _Tp __c11_atomic_load(__gcc_atomic::__gcc_atomic_t<_Tp>* __a, memory_order __order) {
  _Tp __ret;
  __atomic_load(&__a->__a_value, &__ret,
                __gcc_atomic::__to_gcc_order(__order));
  return __ret;
}

template <typename _Tp>
static inline _Tp __c11_atomic_exchange(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a,
                                        _Tp __value, memory_order __order) {
  _Tp __ret;
  __atomic_exchange(&__a->__a_value, &__value, &__ret,
                    __gcc_atomic::__to_gcc_order(__order));
  return __ret;
}

template <typename _Tp>
static inline _Tp __c11_atomic_exchange(__gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp __value,
                                        memory_order __order) {
  _Tp __ret;
  __atomic_exchange(&__a->__a_value, &__value, &__ret,
                    __gcc_atomic::__to_gcc_order(__order));
  return __ret;
}

template <typename _Tp>
static inline bool __c11_atomic_compare_exchange_strong(
    volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp* __expected, _Tp __value,
    memory_order __success, memory_order __failure) {
  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
                                   false,
                                   __gcc_atomic::__to_gcc_order(__success),
                                   __gcc_atomic::__to_gcc_order(__failure));
}

template <typename _Tp>
static inline bool __c11_atomic_compare_exchange_strong(
    __gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp* __expected, _Tp __value, memory_order __success,
    memory_order __failure) {
  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
                                   false,
                                   __gcc_atomic::__to_gcc_order(__success),
                                   __gcc_atomic::__to_gcc_order(__failure));
}

template <typename _Tp>
static inline bool __c11_atomic_compare_exchange_weak(
    volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp* __expected, _Tp __value,
    memory_order __success, memory_order __failure) {
  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
                                   true,
                                   __gcc_atomic::__to_gcc_order(__success),
                                   __gcc_atomic::__to_gcc_order(__failure));
}

template <typename _Tp>
static inline bool __c11_atomic_compare_exchange_weak(
    __gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp* __expected, _Tp __value, memory_order __success,
    memory_order __failure) {
  return __atomic_compare_exchange(&__a->__a_value, __expected, &__value,
                                   true,
                                   __gcc_atomic::__to_gcc_order(__success),
                                   __gcc_atomic::__to_gcc_order(__failure));
}

template <typename _Tp>
struct __skip_amt { enum {value = 1}; };

template <typename _Tp>
struct __skip_amt<_Tp*> { enum {value = sizeof(_Tp)}; };



template <typename _Tp>
struct __skip_amt<_Tp[]> { };
template <typename _Tp, int n>
struct __skip_amt<_Tp[n]> { };

template <typename _Tp, typename _Td>
static inline _Tp __c11_atomic_fetch_add(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a,
                                         _Td __delta, memory_order __order) {
  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp, typename _Td>
static inline _Tp __c11_atomic_fetch_add(__gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Td __delta,
                                         memory_order __order) {
  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp, typename _Td>
static inline _Tp __c11_atomic_fetch_sub(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a,
                                         _Td __delta, memory_order __order) {
  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp, typename _Td>
static inline _Tp __c11_atomic_fetch_sub(__gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Td __delta,
                                         memory_order __order) {
  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_and(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a,
                                         _Tp __pattern, memory_order __order) {
  return __atomic_fetch_and(&__a->__a_value, __pattern,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_and(__gcc_atomic::__gcc_atomic_t<_Tp>* __a,
                                         _Tp __pattern, memory_order __order) {
  return __atomic_fetch_and(&__a->__a_value, __pattern,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_or(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a,
                                        _Tp __pattern, memory_order __order) {
  return __atomic_fetch_or(&__a->__a_value, __pattern,
                           __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_or(__gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp __pattern,
                                        memory_order __order) {
  return __atomic_fetch_or(&__a->__a_value, __pattern,
                           __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_xor(volatile __gcc_atomic::__gcc_atomic_t<_Tp>* __a,
                                         _Tp __pattern, memory_order __order) {
  return __atomic_fetch_xor(&__a->__a_value, __pattern,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_xor(__gcc_atomic::__gcc_atomic_t<_Tp>* __a, _Tp __pattern,
                                         memory_order __order) {
  return __atomic_fetch_xor(&__a->__a_value, __pattern,
                            __gcc_atomic::__to_gcc_order(__order));
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
kill_dependency(_Tp __y) throw()
{
    return __y;
}



template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable __gcc_atomic::__gcc_atomic_t<_Tp> __a_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is_lock_free() const volatile throw()
        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool is_lock_free() const throw()
        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile throw()
        {__c11_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) throw()
        {__c11_atomic_store(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp load(memory_order __m = memory_order_seq_cst) const volatile throw()
        {return __c11_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp load(memory_order __m = memory_order_seq_cst) const throw()
        {return __c11_atomic_load(&__a_, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator _Tp() const volatile throw() {return load();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator _Tp() const throw() {return load();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_exchange(&__a_, __d, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) volatile throw()
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) throw()
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile throw()
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) throw()
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))

    __atomic_base() throw() = default;




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __atomic_base(_Tp __d) throw() : __a_(__d) {}

    __atomic_base(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) = delete;
    __atomic_base& operator=(const __atomic_base&) volatile = delete;






};



template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __atomic_base() throw() = default;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr __atomic_base(_Tp __d) throw() : __base(__d) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_fetch_xor(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator++(int) volatile throw() {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator++(int) throw() {return fetch_add(_Tp(1));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator--(int) volatile throw() {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator--(int) throw() {return fetch_sub(_Tp(1));}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator++() volatile throw() {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator++() throw() {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator--() volatile throw() {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator--() throw() {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator+=(_Tp __op) volatile throw() {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator+=(_Tp __op) throw() {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator-=(_Tp __op) volatile throw() {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator-=(_Tp __op) throw() {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator&=(_Tp __op) volatile throw() {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator&=(_Tp __op) throw() {return fetch_and(__op) & __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator|=(_Tp __op) volatile throw() {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator|=(_Tp __op) throw() {return fetch_or(__op) | __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator^=(_Tp __op) volatile throw() {return fetch_xor(__op) ^ __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator^=(_Tp __op) throw() {return fetch_xor(__op) ^ __op;}
};



template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    atomic() throw() = default;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr atomic(_Tp __d) throw() : __base(__d) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator=(_Tp __d) volatile throw()
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator=(_Tp __d) throw()
        {__base::store(__d); return __d;}
};



template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    typedef __atomic_base<_Tp*> __base;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    atomic() throw() = default;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    constexpr atomic(_Tp* __d) throw() : __base(__d) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator=(_Tp* __d) volatile throw()
        {__base::store(__d); return __d;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator=(_Tp* __d) throw()
        {__base::store(__d); return __d;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile throw()
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)
                                                                        volatile throw()
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_fetch_sub(&this->__a_, __op, __m);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator++(int) volatile throw() {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator++(int) throw() {return fetch_add(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator--(int) volatile throw() {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator--(int) throw() {return fetch_sub(1);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator++() volatile throw() {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator++() throw() {return fetch_add(1) + 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator--() volatile throw() {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator--() throw() {return fetch_sub(1) - 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator+=(ptrdiff_t __op) volatile throw() {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator+=(ptrdiff_t __op) throw() {return fetch_add(__op) + __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator-=(ptrdiff_t __op) volatile throw() {return fetch_sub(__op) - __op;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* operator-=(ptrdiff_t __op) throw() {return fetch_sub(__op) - __op;}
};



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_is_lock_free(const volatile atomic<_Tp>* __o) throw()
{
    return __o->is_lock_free();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_is_lock_free(const atomic<_Tp>* __o) throw()
{
    return __o->is_lock_free();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_init(volatile atomic<_Tp>* __o, _Tp __d) throw()
{
    __c11_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_init(atomic<_Tp>* __o, _Tp __d) throw()
{
    __c11_atomic_init(&__o->__a_, __d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store(volatile atomic<_Tp>* __o, _Tp __d) throw()
{
    __o->store(__d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store(atomic<_Tp>* __o, _Tp __d) throw()
{
    __o->store(__d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) throw()
{
    __o->store(__d, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) throw()
{
    __o->store(__d, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_load(const volatile atomic<_Tp>* __o) throw()
{
    return __o->load();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_load(const atomic<_Tp>* __o) throw()
{
    return __o->load();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) throw()
{
    return __o->load(__m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) throw()
{
    return __o->load(__m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_exchange(volatile atomic<_Tp>* __o, _Tp __d) throw()
{
    return __o->exchange(__d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_exchange(atomic<_Tp>* __o, _Tp __d) throw()
{
    return __o->exchange(__d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) throw()
{
    return __o->exchange(__d, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp
atomic_exchange_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) throw()
{
    return __o->exchange(__d, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) throw()
{
    return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak(atomic<_Tp>* __o, _Tp* __e, _Tp __d) throw()
{
    return __o->compare_exchange_weak(*__e, __d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, _Tp* __e, _Tp __d) throw()
{
    return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong(atomic<_Tp>* __o, _Tp* __e, _Tp __d) throw()
{
    return __o->compare_exchange_strong(*__e, __d);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, _Tp* __e,
                                      _Tp __d,
                                      memory_order __s, memory_order __f) throw()
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, _Tp* __e, _Tp __d,
                                      memory_order __s, memory_order __f) throw()
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
                                        _Tp* __e, _Tp __d,
                                        memory_order __s, memory_order __f) throw()
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, _Tp* __e,
                                        _Tp __d,
                                        memory_order __s, memory_order __f) throw()
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add(volatile atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add(atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_add(volatile atomic<_Tp*>* __o, ptrdiff_t __op) throw()
{
    return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_add(atomic<_Tp*>* __o, ptrdiff_t __op) throw()
{
    return __o->fetch_add(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_add_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_add_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
                          memory_order __m) throw()
{
    return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_add_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) throw()
{
    return __o->fetch_add(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub(volatile atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub(atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_sub(volatile atomic<_Tp*>* __o, ptrdiff_t __op) throw()
{
    return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_sub(atomic<_Tp*>* __o, ptrdiff_t __op) throw()
{
    return __o->fetch_sub(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_sub_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_sub_explicit(volatile atomic<_Tp*>* __o, ptrdiff_t __op,
                          memory_order __m) throw()
{
    return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
atomic_fetch_sub_explicit(atomic<_Tp*>* __o, ptrdiff_t __op, memory_order __m) throw()
{
    return __o->fetch_sub(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(volatile atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_and(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_and(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_and(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_and(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(volatile atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_or(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_or(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_or(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_or(__op, __m);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_xor(__op);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) throw()
{
    return __o->fetch_xor(__op);
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_xor(__op, __m);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) throw()
{
    return __o->fetch_xor(__op, __m);
}



typedef struct atomic_flag
{
    __gcc_atomic::__gcc_atomic_t<bool> __a_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile throw()
        {return __c11_atomic_exchange(&__a_, true, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool test_and_set(memory_order __m = memory_order_seq_cst) throw()
        {return __c11_atomic_exchange(&__a_, true, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear(memory_order __m = memory_order_seq_cst) volatile throw()
        {__c11_atomic_store(&__a_, false, __m);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear(memory_order __m = memory_order_seq_cst) throw()
        {__c11_atomic_store(&__a_, false, __m);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))

    atomic_flag() throw() = default;




    __attribute__ ((__visibility__("hidden"), __always_inline__))
    atomic_flag(bool __b) throw() : __a_(__b) {}


    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;






} atomic_flag;

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) throw()
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_flag_test_and_set(atomic_flag* __o) throw()
{
    return __o->test_and_set();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) throw()
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) throw()
{
    return __o->test_and_set(__m);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_flag_clear(volatile atomic_flag* __o) throw()
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_flag_clear(atomic_flag* __o) throw()
{
    __o->clear();
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) throw()
{
    __o->clear(__m);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) throw()
{
    __o->clear(__m);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_thread_fence(memory_order __m) throw()
{
    __c11_atomic_thread_fence(__m);
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_signal_fence(memory_order __m) throw()
{
    __c11_atomic_signal_fence(__m);
}



typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;

typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;
# 1789 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/atomic" 3
} }
# 615 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__undef_min_max" 1 3
# 618 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 2 3


       
# 621 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3


namespace std { namespace __ndk1 {



template <class _Tp> class allocator;

template <>
class __attribute__ ((__visibility__("default"))) allocator<void>
{
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};

template <>
class __attribute__ ((__visibility__("default"))) allocator<const void>
{
public:
    typedef const void* pointer;
    typedef const void* const_pointer;
    typedef const void value_type;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};
};



template <class _Tp>
struct __has_element_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::element_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef typename _Ptr::element_type type;
};



template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef _Tp type;
};
# 741 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template <class _Tp>
struct __has_difference_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::difference_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{



    typedef typename _Tp::template rebind<_Up>::other type;

};



template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{



    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;

};

template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};
# 875 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template <class _Ptr>
struct __attribute__ ((__visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;




    template <class _Up> struct rebind
        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                           __nat, element_type>::type& __r)
        {return pointer::pointer_to(__r);}
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;




    template <class _Up> struct rebind {typedef _Up* other;};


private:
    struct __nat {};
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer pointer_to(typename conditional<is_void<element_type>::value,
                                      __nat, element_type>::type& __r) throw()
        {return std::__ndk1::addressof(__r);}
};



namespace __has_pointer_type_imp
{
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::pointer* = 0);
}

template <class _Tp>
struct __has_pointer_type
    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>
{
};

namespace __pointer_type_imp
{

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type
{
    typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp>
struct __pointer_type<_Tp, _Dp, false>
{
    typedef _Tp* type;
};

}

template <class _Tp, class _Dp>
struct __pointer_type
{
    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp>
struct __has_const_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer
{
    typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;

};

template <class _Tp>
struct __has_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer
{
    typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;

};

template <class _Tp>
struct __has_const_void_pointer
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer
{
    typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false>
{



    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;

};

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
__to_raw_pointer(_Tp* __p) throw()
{
    return __p;
}

template <class _Pointer>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename pointer_traits<_Pointer>::element_type*
__to_raw_pointer(_Pointer __p) throw()
{
    return std::__ndk1::__to_raw_pointer(__p.operator->());
}

template <class _Tp>
struct __has_size_type
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::size_type* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type
{
    typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true>
{
    typedef typename _Alloc::size_type type;
};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_move_assignment
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp>
struct __has_propagate_on_container_swap
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Up> static __two __test(...);
    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap
{
    typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true>
{
    typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other
{
private:
    struct __two {char __lx; char __lxx;};
    template <class _Xp> static __two __test(...);
    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);
public:
    static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, false>
{
    static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind
{
    typedef typename _Tp::template rebind<_Up>::other type;
};



template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>
{
    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;
};

template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>
{
    typedef _Alloc<_Up, _Args...> type;
};
# 1241 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> decltype(__a.allocate(__sz, __p), true_type());

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto
__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)
    -> false_type;

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : integral_constant<bool,
        is_same<
            decltype(__has_allocate_hint_test(declval<_Alloc>(),
                                          declval<_SizeType>(),
                                          declval<_ConstVoidPtr>())),
            true_type>::value>
{
};
# 1274 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template <class _Alloc, class _Tp, class ..._Args>
decltype(std::__ndk1::declval<_Alloc>().construct(std::__ndk1::declval<_Tp*>(),
                                           std::__ndk1::declval<_Args>()...),
                                           true_type())
__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);

template <class _Alloc, class _Pointer, class ..._Args>
false_type
__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);

template <class _Alloc, class _Pointer, class ..._Args>
struct __has_construct
    : integral_constant<bool,
        is_same<
            decltype(__has_construct_test(declval<_Alloc>(),
                                          declval<_Pointer>(),
                                          declval<_Args>()...)),
            true_type>::value>
{
};

template <class _Alloc, class _Pointer>
auto
__has_destroy_test(_Alloc&& __a, _Pointer&& __p)
    -> decltype(__a.destroy(__p), true_type());

template <class _Alloc, class _Pointer>
auto
__has_destroy_test(const _Alloc& __a, _Pointer&& __p)
    -> false_type;

template <class _Alloc, class _Pointer>
struct __has_destroy
    : integral_constant<bool,
        is_same<
            decltype(__has_destroy_test(declval<_Alloc>(),
                                        declval<_Pointer>())),
            true_type>::value>
{
};

template <class _Alloc>
auto
__has_max_size_test(_Alloc&& __a)
    -> decltype(__a.max_size(), true_type());

template <class _Alloc>
auto
__has_max_size_test(const volatile _Alloc& __a)
    -> false_type;

template <class _Alloc>
struct __has_max_size
    : integral_constant<bool,
        is_same<
            decltype(__has_max_size_test(declval<_Alloc&>())),
            true_type>::value>
{
};

template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(_Alloc&& __a)
    -> decltype(__a.select_on_container_copy_construction(), true_type());

template <class _Alloc>
auto
__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)
    -> false_type;

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : integral_constant<bool,
        is_same<
            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),
            true_type>::value>
{
};
# 1393 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type
{
    typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true>
{
    typedef typename _Alloc::difference_type type;
};

template <class _Alloc>
struct __attribute__ ((__visibility__("default"))) allocator_traits
{
    typedef _Alloc allocator_type;
    typedef typename allocator_type::value_type value_type;

    typedef typename __pointer_type<value_type, allocator_type>::type pointer;
    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;
    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;

    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;
    typedef typename __size_type<allocator_type, difference_type>::type size_type;

    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type
                     propagate_on_container_copy_assignment;
    typedef typename __propagate_on_container_move_assignment<allocator_type>::type
                     propagate_on_container_move_assignment;
    typedef typename __propagate_on_container_swap<allocator_type>::type
                     propagate_on_container_swap;






    template <class _Tp> struct rebind_alloc
        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};
    template <class _Tp> struct rebind_traits
        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n)
        {return __a.allocate(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
        {return allocate(__a, __n, __hint,
            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) throw()
        {__a.deallocate(__p, __n);}


    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)
            {__construct(__has_construct<allocator_type, pointer, _Args...>(),
                         __a, __p, std::__ndk1::forward<_Args>(__args)...);}
# 1484 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type max_size(const allocator_type& __a) throw()
        {return __max_size(__has_max_size<const allocator_type>(), __a);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(const allocator_type& __a)
            {return select_on_container_copy_construction(
                __has_select_on_container_copy_construction<const allocator_type>(),
                __a);}

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)
        {
            for (; __begin1 != __end1; ++__begin1, ++__begin2)
                construct(__a, std::__ndk1::__to_raw_pointer(__begin2), std::__ndk1::move_if_noexcept(*__begin1));
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            std::__ndk1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
            __begin2 += _Np;
        }

    template <class _Ptr>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        void
        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)
        {
            while (__end1 != __begin1)
            {
                construct(__a, std::__ndk1::__to_raw_pointer(__end2-1), std::__ndk1::move_if_noexcept(*--__end1));
                --__end2;
            }
        }

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static
        typename enable_if
        <
            (is_same<allocator_type, allocator<_Tp> >::value
                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&
             is_trivially_move_constructible<_Tp>::value,
            void
        >::type
        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)
        {
            ptrdiff_t _Np = __end1 - __begin1;
            __end2 -= _Np;
            std::__ndk1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
        }

private:

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer __hint, true_type)
        {return __a.allocate(__n, __hint);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static pointer allocate(allocator_type& __a, size_type __n,
        const_void_pointer, false_type)
        {return __a.allocate(__n);}


    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)
            {__a.construct(__p, std::__ndk1::forward<_Args>(__args)...);}
    template <class _Tp, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)
            {
                ::new ((void*)__p) _Tp(std::__ndk1::forward<_Args>(__args)...);
            }


    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(true_type, allocator_type& __a, _Tp* __p)
            {__a.destroy(__p);}
    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static void __destroy(false_type, allocator_type&, _Tp* __p)
            {
                __p->~_Tp();
            }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(true_type, const allocator_type& __a)
            {return __a.max_size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static size_type __max_size(false_type, const allocator_type&)
            {return numeric_limits<size_type>::max();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(true_type, const allocator_type& __a)
            {return __a.select_on_container_copy_construction();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static allocator_type
        select_on_container_copy_construction(false_type, const allocator_type& __a)
            {return __a;}
};



template <class _Tp>
class __attribute__ ((__visibility__("default"))) allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef _Tp& reference;
    typedef const _Tp& const_reference;
    typedef _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer address(reference __x) const throw()
        {return std::__ndk1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__ndk1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {::operator delete((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}

    template <class _Up, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(_Up* __p, _Args&&... __args)
        {
            ::new((void*)__p) _Up(std::__ndk1::forward<_Args>(__args)...);
        }
# 1700 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp>
class __attribute__ ((__visibility__("default"))) allocator<const _Tp>
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp* const_pointer;
    typedef const _Tp& reference;
    typedef const _Tp& const_reference;
    typedef const _Tp value_type;

    typedef true_type propagate_on_container_move_assignment;

    template <class _Up> struct rebind {typedef allocator<_Up> other;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator() throw() {}
    template <class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up>&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) const_pointer address(const_reference __x) const throw()
        {return std::__ndk1::addressof(__x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer allocate(size_type __n, allocator<void>::const_pointer = 0)
        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) throw()
        {::operator delete((void*)__p);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) size_type max_size() const throw()
        {return size_type(~0) / sizeof(_Tp);}

    template <class _Up, class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        construct(_Up* __p, _Args&&... __args)
        {
            ::new((void*)__p) _Up(std::__ndk1::forward<_Args>(__args)...);
        }
# 1790 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) {__p->~_Tp();}
};

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) throw() {return true;}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) throw() {return false;}

template <class _OutputIterator, class _Tp>
class __attribute__ ((__visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp*,
                      raw_storage_iterator<_OutputIterator, _Tp>&>
{
private:
    _OutputIterator __x_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator*() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator=(const _Tp& __element)
        {::new(&*__x_) _Tp(__element); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator& operator++() {++__x_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) raw_storage_iterator operator++(int)
        {raw_storage_iterator __t(*this); ++__x_; return __t;}
};

template <class _Tp>
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) throw()
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void return_temporary_buffer(_Tp* __p) throw() {::operator delete(__p);}

template <class _Tp>
struct auto_ptr_ref
{
    _Tp* __ptr_;
};

template<class _Tp>
class __attribute__ ((__visibility__("default"))) auto_ptr
{
private:
    _Tp* __ptr_;
public:
    typedef _Tp element_type;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr<_Up>& __p) throw()
        : __ptr_(__p.release()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr& __p) throw()
        {reset(__p.release()); return *this;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr<_Up>& __p) throw()
        {reset(__p.release()); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()
        {reset(__p.__ptr_); return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~auto_ptr() throw() {delete __ptr_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp& operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Tp* release() throw()
    {
        _Tp* __t = __ptr_;
        __ptr_ = 0;
        return __t;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(_Tp* __p = 0) throw()
    {
        if (__ptr_ != __p)
            delete __ptr_;
        __ptr_ = __p;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr_ref<_Up>() throw()
        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}
    template<class _Up> __attribute__ ((__visibility__("hidden"), __always_inline__)) operator auto_ptr<_Up>() throw()
        {return auto_ptr<_Up>(release());}
};

template <>
class __attribute__ ((__visibility__("default"))) auto_ptr<void>
{
public:
    typedef void element_type;
};

template <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,
                                                     typename remove_cv<_T2>::type>::value,
                                bool = is_empty<_T1>::value

                                       && !__is_final(_T1)

                                ,
                                bool = is_empty<_T2>::value

                                       && !__is_final(_T2)

         >
struct __libcpp_compressed_pair_switch;

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false> {enum {value = 1};};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true> {enum {value = 2};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true> {enum {value = 3};};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true> {enum {value = 1};};

template <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>
class __libcpp_compressed_pair_imp;

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 0>
{
private:
    _T1 __first_;
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__ndk1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__ndk1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : __first_(std::__ndk1::forward<_T1_param>(__t1)), __second_(std::__ndk1::forward<_T2_param>(__t2)) {}
# 2001 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,
                                     tuple<_Args1...> __first_args,
                                     tuple<_Args2...> __second_args,
                                     __tuple_indices<_I1...>,
                                     __tuple_indices<_I2...>)
            : __first_(std::__ndk1::forward<_Args1>(get<_I1>(__first_args))...),
              __second_(std::__ndk1::forward<_Args2>(get<_I2>(__second_args))...)
            {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)
       

    {
        using std::__ndk1::swap;
        swap(__first_, __x.__first_);
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 1>
    : private _T1
{
private:
    _T2 __second_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef typename remove_reference<_T2>::type& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const typename remove_reference<_T2>::type& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__ndk1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : __second_(std::__ndk1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__ndk1::forward<_T1_param>(__t1)), __second_(std::__ndk1::forward<_T2_param>(__t2)) {}
# 2092 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,
                                     tuple<_Args1...> __first_args,
                                     tuple<_Args2...> __second_args,
                                     __tuple_indices<_I1...>,
                                     __tuple_indices<_I2...>)
            : _T1(std::__ndk1::forward<_Args1>(get<_I1>(__first_args))...),
              __second_(std::__ndk1::forward<_Args2>(get<_I2>(__second_args))...)
            {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return __second_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return __second_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)
       

    {
        using std::__ndk1::swap;
        swap(__second_, __x.__second_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 2>
    : private _T2
{
private:
    _T1 __first_;
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef typename remove_reference<_T1>::type& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const typename remove_reference<_T1>::type& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : __first_(std::__ndk1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__ndk1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
       

        : _T2(std::__ndk1::forward<_T2_param>(__t2)), __first_(std::__ndk1::forward<_T1_param>(__t1)) {}
# 2184 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,
                                     tuple<_Args1...> __first_args,
                                     tuple<_Args2...> __second_args,
                                     __tuple_indices<_I1...>,
                                     __tuple_indices<_I2...>)
            : _T2(std::__ndk1::forward<_Args2>(get<_I2>(__second_args))...),
              __first_(std::__ndk1::forward<_Args1>(get<_I1>(__first_args))...)

            {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return __first_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return __first_;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp& __x)
       

    {
        using std::__ndk1::swap;
        swap(__first_, __x.__first_);
    }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 3>
    : private _T1,
      private _T2
{
public:
    typedef _T1 _T1_param;
    typedef _T2 _T2_param;

    typedef _T1& _T1_reference;
    typedef _T2& _T2_reference;

    typedef const _T1& _T1_const_reference;
    typedef const _T2& _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T1_param __t1)
        : _T1(std::__ndk1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(_T2_param __t2)
        : _T2(std::__ndk1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)
        : _T1(std::__ndk1::forward<_T1_param>(__t1)), _T2(std::__ndk1::forward<_T2_param>(__t2)) {}
# 2274 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,
                                     tuple<_Args1...> __first_args,
                                     tuple<_Args2...> __second_args,
                                     __tuple_indices<_I1...>,
                                     __tuple_indices<_I2...>)
            : _T1(std::__ndk1::forward<_Args1>(get<_I1>(__first_args))...),
              _T2(std::__ndk1::forward<_Args2>(get<_I2>(__second_args))...)
            {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__libcpp_compressed_pair_imp&)
       

    {
    }
};

template <class _T1, class _T2>
class __compressed_pair
    : private __libcpp_compressed_pair_imp<_T1, _T2>
{
    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;
public:
    typedef typename base::_T1_param _T1_param;
    typedef typename base::_T2_param _T2_param;

    typedef typename base::_T1_reference _T1_reference;
    typedef typename base::_T2_reference _T2_reference;

    typedef typename base::_T1_const_reference _T1_const_reference;
    typedef typename base::_T2_const_reference _T2_const_reference;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T1_param __t1)
        : base(std::__ndk1::forward<_T1_param>(__t1)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T2_param __t2)
        : base(std::__ndk1::forward<_T2_param>(__t2)) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __compressed_pair(_T1_param __t1, _T2_param __t2)
        : base(std::__ndk1::forward<_T1_param>(__t1), std::__ndk1::forward<_T2_param>(__t2)) {}
# 2359 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    template <class... _Args1, class... _Args2>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                                                      tuple<_Args2...> __second_args)
            : base(__pc, std::__ndk1::move(__first_args), std::__ndk1::move(__second_args),
                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                   typename __make_tuple_indices<sizeof...(_Args2) >::type())
            {}



    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_reference first() throw() {return base::first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const throw() {return base::first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_reference second() throw() {return base::second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const throw() {return base::second();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(__compressed_pair& __x)
       

        {base::swap(__x);}
};

template <class _T1, class _T2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
       

    {__x.swap(__y);}



template <class _Ptr1, class _Ptr2,
          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,
                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type
                        >::value
         >
struct __same_or_less_cv_qualified_imp
    : is_convertible<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>
    : false_type {};

template <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||
                                           is_same<_Ptr1, _Ptr2>::value ||
                                           __has_element_type<_Ptr1>::value>
struct __same_or_less_cv_qualified
    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>
    : false_type {};



template <class _Tp>
struct __attribute__ ((__visibility__("default"))) default_delete
{

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr default_delete() throw() = default;



    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up>&,
             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator() (_Tp* __ptr) const throw()
        {
            static_assert(sizeof(_Tp) > 0, "default_delete can not delete incomplete type");
            static_assert(!is_void<_Tp>::value, "default_delete can not delete incomplete type");
            delete __ptr;
        }
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) default_delete<_Tp[]>
{
public:

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr default_delete() throw() = default;



    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) default_delete(const default_delete<_Up[]>&,
             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) throw() {}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void operator() (_Up* __ptr,
                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const throw()
        {
            static_assert(sizeof(_Tp) > 0, "default_delete can not delete incomplete type");
            static_assert(!is_void<_Tp>::value, "default_delete can not delete incomplete type");
            delete [] __ptr;
        }
};

template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__ ((__visibility__("default"))) unique_ptr
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;
# 2477 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr unique_ptr() throw()
        : __ptr_(pointer())
        {
            static_assert(!is_pointer<deleter_type>::value,
                "unique_ptr constructed with null function pointer deleter");
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            static_assert(!is_pointer<deleter_type>::value,
                "unique_ptr constructed with null function pointer deleter");
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p) throw()
        : __ptr_(std::__ndk1::move(__p))
        {
            static_assert(!is_pointer<deleter_type>::value,
                "unique_ptr constructed with null function pointer deleter");
        }


    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, typename conditional<
                                        is_reference<deleter_type>::value,
                                        deleter_type,
                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)
             throw()
        : __ptr_(__p, __d) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)
             throw()
        : __ptr_(__p, std::__ndk1::move(__d))
        {
            static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(unique_ptr&& __u) throw()
        : __ptr_(__u.release(), std::__ndk1::forward<deleter_type>(__u.get_deleter())) {}
    template <class _Up, class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_ptr(unique_ptr<_Up, _Ep>&& __u,
                   typename enable_if
                      <
                        !is_array<_Up>::value &&
                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&
                         is_convertible<_Ep, deleter_type>::value &&
                         (
                            !is_reference<deleter_type>::value ||
                            is_same<deleter_type, _Ep>::value
                         ),
                         __nat
                      >::type = __nat()) throw()
            : __ptr_(__u.release(), std::__ndk1::forward<_Ep>(__u.get_deleter())) {}

    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(auto_ptr<_Up>&& __p,
                typename enable_if<
                                      is_convertible<_Up*, _Tp*>::value &&
                                      is_same<_Dp, default_delete<_Tp> >::value,
                                      __nat
                                  >::type = __nat()) throw()
            : __ptr_(__p.release())
            {
            }

        __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(unique_ptr&& __u) throw()
            {
                reset(__u.release());
                __ptr_.second() = std::__ndk1::forward<deleter_type>(__u.get_deleter());
                return *this;
            }

        template <class _Up, class _Ep>
            __attribute__ ((__visibility__("hidden"), __always_inline__))
            typename enable_if
            <
                !is_array<_Up>::value &&
                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&
                is_assignable<deleter_type&, _Ep&&>::value,
                unique_ptr&
            >::type
            operator=(unique_ptr<_Up, _Ep>&& __u) throw()
            {
                reset(__u.release());
                __ptr_.second() = std::__ndk1::forward<_Ep>(__u.get_deleter());
                return *this;
            }
# 2598 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator*() const
        {return *__ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer operator->() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit operator bool() const throw()
        {return __ptr_.first() != nullptr;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer()) throw()
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) throw()
        {__ptr_.swap(__u.__ptr_);}
};

template <class _Tp, class _Dp>
class __attribute__ ((__visibility__("default"))) unique_ptr<_Tp[], _Dp>
{
public:
    typedef _Tp element_type;
    typedef _Dp deleter_type;
    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;
private:
    __compressed_pair<pointer, deleter_type> __ptr_;
# 2656 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    struct __nat {int __for_bool_;};

    typedef typename remove_reference<deleter_type>::type& _Dp_reference;
    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr unique_ptr() throw()
        : __ptr_(pointer())
        {
            static_assert(!is_pointer<deleter_type>::value,
                "unique_ptr constructed with null function pointer deleter");
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr unique_ptr(nullptr_t) throw()
        : __ptr_(pointer())
        {
            static_assert(!is_pointer<deleter_type>::value,
                "unique_ptr constructed with null function pointer deleter");
        }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(_Pp __p,
            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) throw()
        : __ptr_(__p)
        {
            static_assert(!is_pointer<deleter_type>::value,
                "unique_ptr constructed with null function pointer deleter");
        }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(_Pp __p, typename conditional<
                                       is_reference<deleter_type>::value,
                                       deleter_type,
                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,
                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())
             throw()
        : __ptr_(__p, __d) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t, typename conditional<
                                       is_reference<deleter_type>::value,
                                       deleter_type,
                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)
             throw()
        : __ptr_(pointer(), __d) {}

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(_Pp __p,
                                         typename remove_reference<deleter_type>::type&& __d,
                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())
             throw()
        : __ptr_(__p, std::__ndk1::move(__d))
        {
            static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)
             throw()
        : __ptr_(pointer(), std::__ndk1::move(__d))
        {
            static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr(unique_ptr&& __u) throw()
        : __ptr_(__u.release(), std::__ndk1::forward<deleter_type>(__u.get_deleter())) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(unique_ptr&& __u) throw()
        {
            reset(__u.release());
            __ptr_.second() = std::__ndk1::forward<deleter_type>(__u.get_deleter());
            return *this;
        }

    template <class _Up, class _Ep>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        unique_ptr(unique_ptr<_Up, _Ep>&& __u,
                   typename enable_if
                            <
                                is_array<_Up>::value &&
                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value
                                && is_convertible<_Ep, deleter_type>::value &&
                                (
                                    !is_reference<deleter_type>::value ||
                                    is_same<deleter_type, _Ep>::value
                                ),
                                __nat
                            >::type = __nat()
                  ) throw()
        : __ptr_(__u.release(), std::__ndk1::forward<deleter_type>(__u.get_deleter())) {}


        template <class _Up, class _Ep>
            __attribute__ ((__visibility__("hidden"), __always_inline__))
            typename enable_if
            <
                is_array<_Up>::value &&
                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&
                is_assignable<deleter_type&, _Ep&&>::value,
                unique_ptr&
            >::type
            operator=(unique_ptr<_Up, _Ep>&& __u) throw()
            {
                reset(__u.release());
                __ptr_.second() = std::__ndk1::forward<_Ep>(__u.get_deleter());
                return *this;
            }
# 2790 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) ~unique_ptr() {reset();}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) unique_ptr& operator=(nullptr_t) throw()
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const
        {return __ptr_.first()[__i];}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer get() const throw() {return __ptr_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const throw()
        {return __ptr_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit operator bool() const throw()
        {return __ptr_.first() != nullptr;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) pointer release() throw()
    {
        pointer __t = __ptr_.first();
        __ptr_.first() = pointer();
        return __t;
    }


    template <class _Pp>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type
    reset(_Pp __p) throw()
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = __p;
        if (__tmp)
            __ptr_.second()(__tmp);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset(nullptr_t) throw()
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = nullptr;
        if (__tmp)
            __ptr_.second()(__tmp);
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reset() throw()
    {
        pointer __tmp = __ptr_.first();
        __ptr_.first() = nullptr;
        if (__tmp)
            __ptr_.second()(__tmp);
    }
# 2851 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}
private:
# 2869 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
};

template <class _Tp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) throw() {__x.swap(__y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return !__x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw()
{
    return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
{
    return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
{
    return !(nullptr < __x);
}
# 3024 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template<class _Tp>
struct __unique_if
{
    typedef unique_ptr<_Tp> __unique_single;
};

template<class _Tp>
struct __unique_if<_Tp[]>
{
    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template<class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]>
{
    typedef void __unique_array_known_bound;
};

template<class _Tp, class... _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args)
{
    return unique_ptr<_Tp>(new _Tp(std::__ndk1::forward<_Args>(__args)...));
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n)
{
    typedef typename remove_extent<_Tp>::type _Up;
    return unique_ptr<_Tp>(new _Up[__n]());
}

template<class _Tp, class... _Args>
    typename __unique_if<_Tp>::__unique_array_known_bound
    make_unique(_Args&&...) = delete;



template <class _Tp> struct hash;

template <class _Size>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}




template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    _Size operator()(const void* __key, _Size __len);
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = __loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= __data[2] << 16;
    case 2:
        __h ^= __data[1] << 8;
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    _Size operator()(const void* __key, _Size __len);

 private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }

  static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b) {
    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),
                                         __loadword<_Size>(__s + 8),
                                         __loadword<_Size>(__s + 16),
                                         __loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y = __loadword<_Size>(__s + __len - 16) +
              __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                          __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public unary_function<_Tp, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            };
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template<class _Tp>
struct __attribute__ ((__visibility__("default"))) hash<_Tp*>
    : public unary_function<_Tp*, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp* __v) const throw()
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};

template <class _Tp, class _Dp>
struct __attribute__ ((__visibility__("default"))) hash<unique_ptr<_Tp, _Dp> >
{
    typedef unique_ptr<_Tp, _Dp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        typedef typename argument_type::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};

struct __destruct_n
{
private:
    size_t size;

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp* __p, false_type) throw()
        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __process(_Tp*, true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(false_type) throw()
        {++size;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(true_type) throw()
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, false_type) throw()
        {size = __s;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t, true_type) throw()
        {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit __destruct_n(size_t __s) throw()
        : size(__s) {}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __incr(_Tp*) throw()
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, _Tp*) throw()
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}

    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) throw()
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};

template <class _Alloc>
class __allocator_destructor
{
    typedef allocator_traits<_Alloc> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __allocator_destructor(_Alloc& __a, size_type __s)
             throw()
        : __alloc_(__a), __s_(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator
uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __f != __l; ++__f, ++__r)
            ::new(&*__r) value_type(*__f);
# 3499 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator
uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __n > 0; ++__f, ++__r, --__n)
            ::new(&*__r) value_type(*__f);
# 3523 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    return __r;
}

template <class _ForwardIterator, class _Tp>
void
uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __f != __l; ++__f)
            ::new(&*__f) value_type(__x);
# 3547 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;





        for (; __n > 0; ++__f, --__n)
            ::new(&*__f) value_type(__x);
# 3570 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    return __f;
}

class __attribute__ ((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    virtual ~bad_weak_ptr() throw();
    virtual const char* what() const throw();
};

template<class _Tp> class __attribute__ ((__visibility__("default"))) weak_ptr;

class __attribute__ ((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);

protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() throw() = 0;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_count(long __refs = 0) throw()
        : __shared_owners_(__refs) {}

    void __add_shared() throw();
    bool __release_shared() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_owners_ + 1;}
};

class __attribute__ ((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __shared_weak_count(long __refs = 0) throw()
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    virtual ~__shared_weak_count();

public:
    void __add_shared() throw();
    void __add_weak() throw();
    void __release_shared() throw();
    void __release_weak() throw();
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __shared_count::use_count();}
    __shared_weak_count* lock() throw();






    virtual const void* __get_deleter(const type_info&) const throw();

private:
    virtual void __on_zero_shared_weak() throw() = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__ndk1::move(__d)), std::__ndk1::move(__a)) {}





private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
};
# 3668 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() throw()
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(this, 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace
    : public __shared_weak_count
{
    __compressed_pair<_Alloc, _Tp> __data_;
public:


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __shared_ptr_emplace(_Alloc __a)
        : __data_(std::__ndk1::move(__a)) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
            : __data_(piecewise_construct, std::__ndk1::forward_as_tuple(__a),
                   std::__ndk1::forward_as_tuple(std::__ndk1::forward<_Args>(__args)...)) {}
# 3726 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
private:
    virtual void __on_zero_shared() throw();
    virtual void __on_zero_shared_weak() throw();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp* get() throw() {return &__data_.second();}
};

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() throw()
{
    __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void
__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() throw()
{
    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());
    __data_.first().~_Alloc();
    __a.deallocate(this, 1);
}

template<class _Tp> class __attribute__ ((__visibility__("default"))) enable_shared_from_this;

template<class _Tp>
class __attribute__ ((__visibility__("default"))) shared_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

    struct __nat {int __for_bool_;};
public:
    constexpr shared_ptr() throw();
    constexpr shared_ptr(nullptr_t) throw();
    template<class _Yp>
        explicit shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp>
        shared_ptr(_Yp* __p, _Dp __d,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template<class _Yp, class _Dp, class _Alloc>
        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());
    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) throw();
    shared_ptr(const shared_ptr& __r) throw();
    template<class _Yp>
        shared_ptr(const shared_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())
                       throw();

    shared_ptr(shared_ptr&& __r) throw();
    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())
                       throw();

    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());

    template<class _Yp>
        shared_ptr(auto_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());






    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       !is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
    template <class _Yp, class _Dp>
        shared_ptr(unique_ptr<_Yp, _Dp>&&,
                   typename enable_if
                   <
                       is_lvalue_reference<_Dp>::value &&
                       !is_array<_Yp>::value &&
                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                       __nat
                   >::type = __nat());
# 3839 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    ~shared_ptr();

    shared_ptr& operator=(const shared_ptr& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr&
        >::type
        operator=(const shared_ptr<_Yp>& __r) throw();

    shared_ptr& operator=(shared_ptr&& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr<_Tp>&
        >::type
        operator=(shared_ptr<_Yp>&& __r);
    template<class _Yp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<_Yp*, element_type*>::value,
            shared_ptr
        >::type&
        operator=(auto_ptr<_Yp>&& __r);
# 3876 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    template <class _Yp, class _Dp>
        typename enable_if
        <
            !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
            shared_ptr&
        >::type

        operator=(unique_ptr<_Yp, _Dp>&& __r);




    void swap(shared_ptr& __r) throw();
    void reset() throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p);
    template<class _Yp, class _Dp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d);
    template<class _Yp, class _Dp, class _Alloc>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            void
        >::type
        reset(_Yp* __p, _Dp __d, _Alloc __a);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* get() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    typename add_lvalue_reference<element_type>::type operator*() const throw()
        {return *__ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    element_type* operator->() const throw() {return __ptr_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw() {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool unique() const throw() {return use_count() == 1;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit operator bool() const throw() {return get() != 0;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(shared_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    template <class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(weak_ptr<_Up> const& __p) const
        {return __cntrl_ < __p.__cntrl_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool
    __owner_equivalent(const shared_ptr& __p) const
        {return __cntrl_ == __p.__cntrl_;}
# 3948 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
    template<class ..._Args>
        static
        shared_ptr<_Tp>
        make_shared(_Args&& ...__args);

    template<class _Alloc, class ..._Args>
        static
        shared_ptr<_Tp>
        allocate_shared(const _Alloc& __a, _Args&& ...__args);
# 3989 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
private:

    template <class _Yp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        void
        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) throw()
        {
            if (__e)
                __e->__weak_this_ = *this;
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __enable_weak_this(const void*) throw() {}

    template <class _Up> friend class __attribute__ ((__visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__ ((__visibility__("default"))) weak_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
shared_ptr<_Tp>::shared_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
shared_ptr<_Tp>::shared_ptr(nullptr_t) throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{
    unique_ptr<_Yp> __hold(__p);
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());
    __hold.release();
    __enable_weak_this(__p);
}

template<class _Tp>
template<class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{




        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());
        __enable_weak_this(__p);
# 4059 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
}

template<class _Tp>
template<class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)
    : __ptr_(0)
{




        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());
# 4080 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__p)
{




        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();
        __enable_weak_this(__p);
# 4108 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
}

template<class _Tp>
template<class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
    : __ptr_(0)
{




        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
        typedef __allocator_destructor<_A2> _D2;
        _A2 __a2(__a);
        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);
        __cntrl_ = __hold2.release();
# 4134 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) throw()
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_shared();
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}



template<class _Tp>
template<class _Yp>

shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,



                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,



                            typename enable_if
                            <
                                !is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}

template<class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,



                            typename enable_if
                            <
                                is_lvalue_reference<_Dp>::value &&
                                !is_array<_Yp>::value &&
                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,
                                __nat
                            >::type)
    : __ptr_(__r.get())
{
    typedef __shared_ptr_pointer<_Yp*,
                                 reference_wrapper<typename remove_reference<_Dp>::type>,
                                 allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());
    __enable_weak_this(__r.get());
    __r.release();
}



template<class _Tp>
template<class ..._Args>
shared_ptr<_Tp>
shared_ptr<_Tp>::make_shared(_Args&& ...__args)
{
    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;
    typedef allocator<_CntrlBlk> _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2;
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a2, std::__ndk1::forward<_Args>(__args)...);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}

template<class _Tp>
template<class _Alloc, class ..._Args>
shared_ptr<_Tp>
shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new(__hold2.get()) _CntrlBlk(__a, std::__ndk1::forward<_Args>(__args)...);
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __hold2.get()->get();
    __r.__cntrl_ = __hold2.release();
    __r.__enable_weak_this(__r.__ptr_);
    return __r;
}
# 4444 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template<class _Tp>
shared_ptr<_Tp>::~shared_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_shared();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(const shared_ptr& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) throw()
{
    shared_ptr(__r).swap(*this);
    return *this;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>&
shared_ptr<_Tp>::operator=(shared_ptr&& __r) throw()
{
    shared_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)
{
    shared_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<_Yp*, _Tp*>::value,
    shared_ptr<_Tp>
>::type&
shared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)
{
    shared_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template <class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Yp>::value &&
    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,
    shared_ptr<_Tp>&
>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)
{
    shared_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}
# 4563 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::swap(shared_ptr& __r) throw()
{
    std::__ndk1::swap(__ptr_, __r.__ptr_);
    std::__ndk1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
shared_ptr<_Tp>::reset() throw()
{
    shared_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p)
{
    shared_ptr(__p).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)
{
    shared_ptr(__p, __d).swap(*this);
}

template<class _Tp>
template<class _Yp, class _Dp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    void
>::type
shared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)
{
    shared_ptr(__p, __d, __a).swap(*this);
}



template<class _Tp, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value,
    shared_ptr<_Tp>
>::type
make_shared(_Args&& ...__args)
{
    return shared_ptr<_Tp>::make_shared(std::__ndk1::forward<_Args>(__args)...);
}

template<class _Tp, class _Alloc, class ..._Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value,
    shared_ptr<_Tp>
>::type
allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    return shared_ptr<_Tp>::allocate_shared(__a, std::__ndk1::forward<_Args>(__args)...);
}
# 4713 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __x.get() == __y.get();
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x == __y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    typedef typename common_type<_Tp*, _Up*>::type _V;
    return less<_V>()(__x.get(), __y.get());
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return __y < __x;
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__y < __x);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw()
{
    return !(__x < __y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !__x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return static_cast<bool>(__x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return less<_Tp*>()(__x.get(), nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return less<_Tp*>()(nullptr, __x.get());
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return nullptr < __x;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return __x < nullptr;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator<=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) throw()
{
    return !(__x < nullptr);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) throw()
{
    return !(nullptr < __x);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
static_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));
}

template<class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_array<_Tp>::value && !is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
dynamic_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    _Tp* __p = dynamic_cast<_Tp*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template<class _Tp, class _Up>
typename enable_if
<
    is_array<_Tp>::value == is_array<_Up>::value,
    shared_ptr<_Tp>
>::type
const_pointer_cast(const shared_ptr<_Up>& __r) throw()
{
    typedef typename remove_extent<_Tp>::type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}
# 4915 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory" 3
template<class _Tp>
class __attribute__ ((__visibility__("default"))) weak_ptr
{
public:
    typedef _Tp element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;

public:
    constexpr weak_ptr() throw();
    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                        throw();
    weak_ptr(weak_ptr const& __r) throw();
    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         throw();


    weak_ptr(weak_ptr&& __r) throw();
    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,
                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)
                         throw();

    ~weak_ptr();

    weak_ptr& operator=(weak_ptr const& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(weak_ptr<_Yp> const& __r) throw();



    weak_ptr& operator=(weak_ptr&& __r) throw();
    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(weak_ptr<_Yp>&& __r) throw();



    template<class _Yp>
        typename enable_if
        <
            is_convertible<_Yp*, element_type*>::value,
            weak_ptr&
        >::type
        operator=(shared_ptr<_Yp> const& __r) throw();

    void swap(weak_ptr& __r) throw();
    void reset() throw();

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    long use_count() const throw()
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool expired() const throw()
        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const throw();
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const shared_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool owner_before(const weak_ptr<_Up>& __r) const
        {return __cntrl_ < __r.__cntrl_;}

    template <class _Up> friend class __attribute__ ((__visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__ ((__visibility__("default"))) shared_ptr;
};

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
constexpr
weak_ptr<_Tp>::weak_ptr() throw()
    : __ptr_(0),
      __cntrl_(0)
{
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
                         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)
         throw()
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = 0;
    __r.__cntrl_ = 0;
}



template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}



template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) throw()
{
    weak_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}

template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) throw()
{
    weak_ptr(std::__ndk1::move(__r)).swap(*this);
    return *this;
}



template<class _Tp>
template<class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_convertible<_Yp*, _Tp*>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) throw()
{
    weak_ptr(__r).swap(*this);
    return *this;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::swap(weak_ptr& __r) throw()
{
    std::__ndk1::swap(__ptr_, __r.__ptr_);
    std::__ndk1::swap(__cntrl_, __r.__cntrl_);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) throw()
{
    __x.swap(__y);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
weak_ptr<_Tp>::reset() throw()
{
    weak_ptr().swap(*this);
}

template<class _Tp>
template<class _Yp>
shared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,
                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
{
    if (__cntrl_ == 0)



        ((!"bad_weak_ptr") ? (void)0 : __assert2("/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/memory", 5174, __PRETTY_FUNCTION__, "!\"bad_weak_ptr\""));

}

template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const throw()
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}

template <class _Tp> struct owner_less;

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    typedef bool result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const
        {return __x.owner_before(__y);}
};

template<class _Tp>
class __attribute__ ((__visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    enable_shared_from_this() throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this(enable_shared_from_this const&) throw() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    enable_shared_from_this& operator=(enable_shared_from_this const&) throw()
        {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~enable_shared_from_this() {}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}

    template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__ ((__visibility__("default"))) hash<shared_ptr<_Tp> >
{
    typedef shared_ptr<_Tp> argument_type;
    typedef size_t result_type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    result_type operator()(const argument_type& __ptr) const throw()
    {
        return hash<_Tp*>()(__ptr.get());
    }
};

template<class _CharT, class _Traits, class _Yp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);



class __attribute__ ((__visibility__("default"))) __sp_mut
{
    void* __lx;
public:
    void lock() throw();
    void unlock() throw();

private:
    constexpr __sp_mut(void*) throw();
    __sp_mut(const __sp_mut&);
    __sp_mut& operator=(const __sp_mut&);

    friend __attribute__ ((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);
};

__attribute__ ((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_is_lock_free(const shared_ptr<_Tp>*)
{
    return false;
}

template <class _Tp>
shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp>* __p)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    shared_ptr<_Tp> __q = *__p;
    __m.unlock();
    return __q;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
{
    return atomic_load(__p);
}

template <class _Tp>
void
atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    atomic_store(__p, __r);
}

template <class _Tp>
shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
    return __r;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    return atomic_exchange(__p, __r);
}

template <class _Tp>
bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    __sp_mut& __m = __get_sp_mut(__p);
    __m.lock();
    if (__p->__owner_equivalent(*__v))
    {
        *__p = __w;
        __m.unlock();
        return true;
    }
    *__v = *__p;
    __m.unlock();
    return false;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                        shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                      shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return atomic_compare_exchange_weak(__p, __v, __w);
}




struct __attribute__ ((__visibility__("default"))) pointer_safety
{
    enum __lx
    {
        relaxed,
        preferred,
        strict
    };

    __lx __v_;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer_safety(__lx __v) : __v_(__v) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    operator int() const {return __v_;}
};

__attribute__ ((__visibility__("default"))) void declare_reachable(void* __p);
__attribute__ ((__visibility__("default"))) void declare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) void undeclare_no_pointers(char* __p, size_t __n);
__attribute__ ((__visibility__("default"))) pointer_safety get_pointer_safety() throw();
__attribute__ ((__visibility__("default"))) void* __undeclare_reachable(void* __p);

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp*
undeclare_reachable(_Tp* __p)
{
    return static_cast<_Tp*>(__undeclare_reachable(__p));
}

__attribute__ ((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);

} }
# 17 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 2 3

# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/algorithm" 1 3
# 639 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/algorithm" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__undef_min_max" 1 3
# 640 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/algorithm" 2 3


       
# 643 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/algorithm" 3


namespace std { namespace __ndk1 {




template <class _T1, class _T2 = _T1>
struct __equal_to
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1>
struct __equal_to<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}
};

template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};

template <class _Predicate>
class __negate
{
private:
    _Predicate __p_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __negate() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __negate(_Predicate __p) : __p_(__p) {}

    template <class _T1>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x) {return !__p_(__x);}

    template <class _T1, class _T2>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}
};
# 757 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/algorithm" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__ctz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_ctz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__ctz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_ctzl(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__ctz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_ctzll(__x));
}


inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned
__clz(unsigned __x)
{
    return static_cast<unsigned>(__builtin_clz(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long
__clz(unsigned long __x)
{
    return static_cast<unsigned long>(__builtin_clzl (__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unsigned long long
__clz(unsigned long long __x)
{
    return static_cast<unsigned long long>(__builtin_clzll(__x));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned __x) {return __builtin_popcount (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long __x) {return __builtin_popcountl (__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _InputIterator, class _Function>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    for (; __first != __last; ++__first)
        __f(*__first);
    return std::__ndk1::move(__f);
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}



template<class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}



template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
           forward_iterator_tag, forward_iterator_tag)
{

    _ForwardIterator1 __r = __last1;
    if (__first2 == __last2)
        return __r;
    while (true)
    {
        while (true)
        {
            if (__first1 == __last1)
                return __r;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
            {
                __r = __first1;
                ++__first1;
                break;
            }
            if (++__m1 == __last1)
                return __r;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,
           bidirectional_iterator_tag, bidirectional_iterator_tag)
{

    if (__first2 == __last2)
        return __last1;
    _BidirectionalIterator1 __l1 = __last1;
    _BidirectionalIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {

        while (true)
        {
            if (__first1 == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }

        _BidirectionalIterator1 __m1 = __l1;
        _BidirectionalIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;
            if (__m1 == __first1)
                return __last1;
            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
_RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{

    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __last1;
    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
    _RandomAccessIterator1 __l1 = __last1;
    _RandomAccessIterator2 __l2 = __last2;
    --__l2;
    while (true)
    {
        while (true)
        {
            if (__s == __l1)
                return __last1;
            if (__pred(*--__l1, *__l2))
                break;
        }
        _RandomAccessIterator1 __m1 = __l1;
        _RandomAccessIterator2 __m2 = __l2;
        while (true)
        {
            if (__m2 == __first2)
                return __m1;

            if (!__pred(*--__m1, *--__m2))
            {
                break;
            }
        }
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__ndk1::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__ndk1::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__ndk1::find_first_of(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__first, *__i))
                return __first;
            __first = __i;
        }
    }
    return __last;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__ndk1::adjacent_find(__first, __last, __equal_to<__v>());
}



template <class _InputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}



template <class _InputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}



template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__ndk1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _BinaryPredicate __pred)
{
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__ndk1::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}




template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)
{
    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__ndk1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__equal(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,
        input_iterator_tag, input_iterator_tag )
{
    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            return false;
    return __first1 == __last1 && __first2 == __last2;
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
      random_access_iterator_tag, random_access_iterator_tag )
{
    if ( std::__ndk1::distance(__first1, __last1) != std::__ndk1::distance(__first2, __last2))
        return false;
    return std::__ndk1::equal<_RandomAccessIterator1, _RandomAccessIterator2,
                        typename add_lvalue_reference<_BinaryPredicate>::type>
                       (__first1, __last1, __first2, __pred );
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )
{
    return std::__ndk1::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>
       (__first1, __last1, __first2, __last2, __pred,
        typename iterator_traits<_InputIterator1>::iterator_category(),
        typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::__ndk1::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
        typename iterator_traits<_InputIterator1>::iterator_category(),
        typename iterator_traits<_InputIterator2>::iterator_category());
}




template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _BinaryPredicate __pred)
{

    for (; __first1 != __last1; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return true;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__ndk1::distance(__first1, __last1);
    if (__l1 == _D1(1))
        return false;
    _ForwardIterator2 __last2 = std::__ndk1::next(__first2, __l1);


    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__ndk1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__ndk1::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}


template<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
bool
__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                 _BinaryPredicate __pred,
                 forward_iterator_tag, forward_iterator_tag )
{

    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
        if (!__pred(*__first1, *__first2))
            goto __not_done;
    return __first1 == __last1 && __first2 == __last2;
__not_done:

    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
    _D1 __l1 = std::__ndk1::distance(__first1, __last1);

    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;
    _D2 __l2 = std::__ndk1::distance(__first2, __last2);
    if (__l1 != __l2)
        return false;



    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)
    {

        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
            if (__pred(*__j, *__i))
                goto __next_iter;
        {

            _D1 __c2 = 0;
            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
                if (__pred(*__i, *__j))
                    ++__c2;
            if (__c2 == 0)
                return false;

            _D1 __c1 = 1;
            for (_ForwardIterator1 __j = std::__ndk1::next(__i); __j != __last1; ++__j)
                if (__pred(*__i, *__j))
                    ++__c1;
            if (__c1 != __c2)
                return false;
        }
__next_iter:;
    }
    return true;
}

template<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
bool
__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,
               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,
               _BinaryPredicate __pred,
               random_access_iterator_tag, random_access_iterator_tag )
{
    if ( std::__ndk1::distance(__first1, __last1) != std::__ndk1::distance(__first2, __last2))
        return false;
    return std::__ndk1::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,
                                 typename add_lvalue_reference<_BinaryPredicate>::type>
                                (__first1, __last1, __first2, __pred );
}

template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2,
               _BinaryPredicate __pred )
{
    return std::__ndk1::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>
       (__first1, __last1, __first2, __last2, __pred,
        typename iterator_traits<_ForwardIterator1>::iterator_category(),
        typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template<class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__ndk1::__is_permutation(__first1, __last1, __first2, __last2,
        __equal_to<__v1, __v2>(),
        typename iterator_traits<_ForwardIterator1>::iterator_category(),
        typename iterator_traits<_ForwardIterator2>::iterator_category());
}




template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>
_ForwardIterator1
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,
         forward_iterator_tag, forward_iterator_tag)
{
    if (__first2 == __last2)
        return __first1;
    while (true)
    {

        while (true)
        {
            if (__first1 == __last1)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }

        _ForwardIterator1 __m1 = __first1;
        _ForwardIterator2 __m2 = __first2;
        while (true)
        {
            if (++__m2 == __last2)
                return __first1;
            if (++__m1 == __last1)
                return __last1;
            if (!__pred(*__m1, *__m2))
            {
                ++__first1;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
_RandomAccessIterator1
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
           random_access_iterator_tag, random_access_iterator_tag)
{
    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;
    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;

    _D2 __len2 = __last2 - __first2;
    if (__len2 == 0)
        return __first1;
    _D1 __len1 = __last1 - __first1;
    if (__len1 < __len2)
        return __last1;
    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);
    while (true)
    {

        while (true)
        {
            if (__first1 == __s)
                return __last1;
            if (__pred(*__first1, *__first2))
                break;
            ++__first1;
        }
# 1500 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/algorithm" 3
        _RandomAccessIterator1 __m1 = __first1;
        _RandomAccessIterator2 __m2 = __first2;

         while (true)
         {
             if (++__m2 == __last2)
                 return __first1;
             ++__m1;
             if (!__pred(*__m1, *__m2))
             {
                 ++__first1;
                 break;
             }
         }
# 1551 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/algorithm" 3
    }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return std::__ndk1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>
                         (__first1, __last1, __first2, __last2, __pred,
                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),
                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2)
{
    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;
    return std::__ndk1::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());
}



template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator
__search_n(_ForwardIterator __first, _ForwardIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)
{
    if (__count <= 0)
        return __first;
    while (true)
    {

        while (true)
        {
            if (__first == __last)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _ForwardIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
            if (++__m == __last)
                return __last;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>
_RandomAccessIterator
__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)
{
    if (__count <= 0)
        return __first;
    _Size __len = static_cast<_Size>(__last - __first);
    if (__len < __count)
        return __last;
    const _RandomAccessIterator __s = __last - (__count - 1);
    while (true)
    {

        while (true)
        {
            if (__first >= __s)
                return __last;
            if (__pred(*__first, __value_))
                break;
            ++__first;
        }

        _RandomAccessIterator __m = __first;
        _Size __c(0);
        while (true)
        {
            if (++__c == __count)
                return __first;
             ++__m;
            if (!__pred(*__m, __value_))
            {
                __first = __m;
                ++__first;
                break;
            }
        }
    }
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last,
         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)
{
    return std::__ndk1::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>
           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__ndk1::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());
}



template <class _Iter>
struct __libcpp_is_trivial_iterator
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >
{
    static const bool value = is_pointer<_Iter>::value;
};

template <class _Iter>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Iter
__unwrap_iter(_Iter __i)
{
    return __i;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(move_iterator<_Tp*> __i)
{
    return __i.base();
}



template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_trivially_copy_assignable<_Tp>::value,
    _Tp*
>::type
__unwrap_iter(__wrap_iter<_Tp*> __i)
{
    return __i.base();
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = *__first;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__ndk1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__ndk1::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = *--__last;
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__ndk1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__ndk1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template<class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_input_iterator<_InputIterator>::value &&
   !__is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    __is_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
{
    return std::__ndk1::copy(__first, __first + __n, __result);
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = std::__ndk1::move(*__first);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    std::__ndk1::memmove(__result, __first, __n * sizeof(_Up));
    return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    return std::__ndk1::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    while (__first != __last)
        *--__result = std::__ndk1::move(*--__last);
    return __result;
}

template <class _Tp, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_same<typename remove_const<_Tp>::type, _Up>::value &&
    is_trivially_copy_assignable<_Up>::value,
    _Up*
>::type
__move_backward(_Tp* __first, _Tp* __last, _Up* __result)
{
    const size_t __n = static_cast<size_t>(__last - __first);
    __result -= __n;
    std::__ndk1::memmove(__result, __first, __n * sizeof(_Up));
    return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
    return std::__ndk1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}







template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}



template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __value_;
    return __first;
}

template <class _Tp, class _Size, class _Up>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
    !is_same<_Tp, bool>::value &&
    is_integral<_Up>::value && sizeof(_Up) == 1,
    _Tp*
>::type
__fill_n(_Tp* __first, _Size __n,_Up __value_)
{
    if (__n > 0)
        std::__ndk1::memset(__first, (unsigned char)__value_, (size_t)(__n));
    return __first + __n;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)
{
   return std::__ndk1::__fill_n(__first, __n, __value_);
}



template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)
{
    std::__ndk1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    std::__ndk1::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}



template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
{
    for (; __n > 0; ++__first, --__n)
        *__first = __gen();
    return __first;
}



template <class _ForwardIterator, class _Tp>
_ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    __first = std::__ndk1::find(__first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value_))
            {
                *__first = std::__ndk1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _ForwardIterator, class _Predicate>
_ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::__ndk1::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>
                           (__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::__ndk1::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value_))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}



template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)
{
    __first = std::__ndk1::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>
                                 (__first, __last, __pred);
    if (__first != __last)
    {


        _ForwardIterator __i = __first;
        for (++__i; ++__i != __last;)
            if (!__pred(*__first, *__i))
                *++__first = std::__ndk1::move(*__i);
        ++__first;
    }
    return __first;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type __v;
    return std::__ndk1::unique(__first, __last, __equal_to<__v>());
}



template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        typename iterator_traits<_InputIterator>::value_type __t(*__first);
        *__result = __t;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(__t, *__first))
            {
                __t = *__first;
                *__result = __t;
                ++__result;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,
              forward_iterator_tag, output_iterator_tag)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        *__result = *__i;
        ++__result;
        while (++__first != __last)
        {
            if (!__pred(*__i, *__first))
            {
                *__result = *__first;
                ++__result;
                __i = __first;
            }
        }
    }
    return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,
              input_iterator_tag, forward_iterator_tag)
{
    if (__first != __last)
    {
        *__result = *__first;
        while (++__first != __last)
            if (!__pred(*__result, *__first))
                *++__result = *__first;
        ++__result;
    }
    return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)
{
    return std::__ndk1::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>
                              (__first, __last, __result, __pred,
                               typename iterator_traits<_InputIterator>::iterator_category(),
                               typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::value_type __v;
    return std::__ndk1::unique_copy(__first, __last, __result, __equal_to<__v>());
}



template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            swap(*__first, *__last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    std::__ndk1::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}



template <class _ForwardIterator>
_ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    value_type __tmp = std::__ndk1::move(*__first);
    _ForwardIterator __lm1 = std::__ndk1::move(std::__ndk1::next(__first), __last, __first);
    *__lm1 = std::__ndk1::move(__tmp);
    return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    _BidirectionalIterator __lm1 = std::__ndk1::prev(__last);
    value_type __tmp = std::__ndk1::move(*__lm1);
    _BidirectionalIterator __fp1 = std::__ndk1::move_backward(__first, __lm1, __last);
    *__first = std::__ndk1::move(__tmp);
    return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        swap(*__first, *__i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            swap(*__first, *__i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}

template<typename _Integral>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Integral
__gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}

template<typename _RandomAccessIterator>
_RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;

    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = __last - __middle;
    if (__m1 == __m2)
    {
        std::__ndk1::swap_ranges(__first, __middle, __middle);
        return __middle;
    }
    const difference_type __g = std::__ndk1::__gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(std::__ndk1::move(*--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = std::__ndk1::move(*__p2);
            __p1 = __p2;
            const difference_type __d = __last - __p2;
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::__ndk1::move(__t);
    }
    return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::__ndk1::forward_iterator_tag)
{
    typedef typename std::__ndk1::iterator_traits<_ForwardIterator>::value_type value_type;
    if (std::__ndk1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__ndk1::next(__first) == __middle)
            return std::__ndk1::__rotate_left(__first, __last);
    }
    return std::__ndk1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         std::__ndk1::bidirectional_iterator_tag)
{
    typedef typename std::__ndk1::iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (std::__ndk1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__ndk1::next(__first) == __middle)
            return std::__ndk1::__rotate_left(__first, __last);
        if (std::__ndk1::next(__middle) == __last)
            return std::__ndk1::__rotate_right(__first, __last);
    }
    return std::__ndk1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         std::__ndk1::random_access_iterator_tag)
{
    typedef typename std::__ndk1::iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (std::__ndk1::is_trivially_move_assignable<value_type>::value)
    {
        if (std::__ndk1::next(__first) == __middle)
            return std::__ndk1::__rotate_left(__first, __last);
        if (std::__ndk1::next(__middle) == __last)
            return std::__ndk1::__rotate_right(__first, __last);
        return std::__ndk1::__rotate_gcd(__first, __middle, __last);
    }
    return std::__ndk1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    if (__first == __middle)
        return __last;
    if (__middle == __last)
        return __first;
    return std::__ndk1::__rotate(__first, __middle, __last,
                           typename std::__ndk1::iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::__ndk1::copy(__first, __middle, std::__ndk1::copy(__middle, __last, __result));
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_ForwardIterator
__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__i, *__first))
                __first = __i;
    }
    return __first;
}

template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return __min_element(__first, __last, __comp);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return __min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::__ndk1::min(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp
min(initializer_list<_Tp> __t, _Compare __comp)
{
    return *__min_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp
min(initializer_list<_Tp> __t)
{
    return *__min_element(__t.begin(), __t.end(), __less<_Tp>());
}





template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_ForwardIterator
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}


template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return __max_element(__first, __last, __comp);
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return __max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::__ndk1::max(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp
max(initializer_list<_Tp> __t, _Compare __comp)
{
    return *__max_element(__t.begin(), __t.end(), __comp);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
_Tp
max(initializer_list<_Tp> __t)
{
    return *__max_element(__t.begin(), __t.end(), __less<_Tp>());
}





template <class _ForwardIterator, class _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last)
  {
      if (++__first != __last)
      {
          if (__comp(*__first, *__result.first))
              __result.first = __first;
          else
              __result.second = __first;
          while (++__first != __last)
          {
              _ForwardIterator __i = __first;
              if (++__first == __last)
              {
                  if (__comp(*__i, *__result.first))
                      __result.first = __i;
                  else if (!__comp(*__i, *__result.second))
                      __result.second = __i;
                  break;
              }
              else
              {
                  if (__comp(*__first, *__i))
                  {
                      if (__comp(*__first, *__result.first))
                          __result.first = __first;
                      if (!__comp(*__i, *__result.second))
                          __result.second = __i;
                  }
                  else
                  {
                      if (__comp(*__i, *__result.first))
                          __result.first = __i;
                      if (!__comp(*__first, *__result.second))
                          __result.second = __first;
                  }
              }
          }
      }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__ndk1::minmax_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::__ndk1::minmax(__a, __b, __less<_Tp>());
}



template<class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t, _Compare __comp)
{
    typedef typename initializer_list<_Tp>::const_iterator _Iter;
    _Iter __first = __t.begin();
    _Iter __last = __t.end();
    std::pair<_Tp, _Tp> __result ( *__first, *__first );

    ++__first;
    if (__t.size() % 2 == 0)
    {
        if (__comp(*__first, __result.first))
            __result.first = *__first;
        else
            __result.second = *__first;
        ++__first;
    }

    while (__first != __last)
    {
        _Tp __prev = *__first++;
        if (__comp(__prev, *__first)) {
            if (__comp(__prev, __result.first)) __result.first = __prev;
            if (__comp(__result.second, *__first)) __result.second = *__first;
            }
        else {
            if (__comp(*__first, __result.first)) __result.first = *__first;
            if (__comp(__result.second, __prev)) __result.second = __prev;
            }

        __first++;
    }
    return __result;
}

template<class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t)
{
    return std::__ndk1::minmax(__t, __less<_Tp>());
}







template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<_Xp, 0>
{
    static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<0, _Rp>
{
    static const size_t value = _Rp + 1;
};

template <class _UI, _UI _Xp>
struct __log2
{
    static const size_t value = __log2_imp<_Xp,
                                         sizeof(_UI) * 8 - 1>::value;
};

template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:

    typedef _UIntType result_type;

private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef typename conditional
        <
            sizeof(_Engine_result_type) <= sizeof(result_type),
                result_type,
                _Engine_result_type
        >::type _Working_result_type;

    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;





    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);

    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

    __independent_bits_engine(_Engine& __e, size_t __w);


    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}

private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};

template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}

template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}

template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WDt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WDt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}



template<class _IntType = int>
class uniform_int_distribution
{
public:

    typedef _IntType result_type;

    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;

        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}

        result_type a() const {return __a_;}
        result_type b() const {return __b_;}

        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };

private:
    param_type __p_;

public:

    explicit uniform_int_distribution(result_type __a = 0,
                                      result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}


    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);


    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}

    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}

    result_type min() const {return a();}
    result_type max() const {return b();}

    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};

template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
{
    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                                            uint32_t, uint64_t>::type _UIntType;
    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - __clz(_Rp) - 1;
    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}

class __attribute__ ((__visibility__("default"))) __rs_default;

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

class __attribute__ ((__visibility__("default"))) __rs_default
{
    static unsigned __c_;

    __rs_default();
public:
    typedef uint_fast32_t result_type;

    static const result_type _Min = 0;
    static const result_type _Max = 0xFFFFFFFF;

    __rs_default(const __rs_default&);
    ~__rs_default();

    result_type operator()();

    static constexpr result_type min() {return _Min;}
    static constexpr result_type max() {return _Max;}

    friend __attribute__ ((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__ ((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        __rs_default __g = __rs_get();
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

               _RandomNumberGenerator&& __rand)



{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        for (--__last; __first < __last; ++__first, --__d)
        {
            difference_type __i = __rand(__d);
            swap(*__first, *(__first + __i));
        }
    }
}

template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>
    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

                 _UniformRandomNumberGenerator&& __g)



{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, --__d; __first < __last; ++__first, --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                swap(*__first, *(__first + __i));
        }
    }
}

template <class _InputIterator, class _Predicate>
bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}



template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    for (_ForwardIterator __p = __first; ++__p != __last;)
    {
        if (__pred(*__p))
        {
            swap(*__first, *__p);
            ++__first;
        }
    }
    return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
            bidirectional_iterator_tag)
{
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return __first;
        } while (!__pred(*__last));
        swap(*__first, *__last);
        ++__first;
    }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return std::__ndk1::__partition<typename add_lvalue_reference<_Predicate>::type>
                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}



template<class _ForwardIterator, class _Predicate>
_ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__ndk1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__ndk1::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}



template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{


    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__ndk1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__ndk1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__ndk1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }


        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__ndk1::move(*__t2);

        return __first;
    }


    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__ndk1::advance(__m, __len2);



    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);



    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


    return std::__ndk1::rotate(__first_false, __m, __second_false);


}

struct __return_temporary_buffer
{
    template <class _Tp>
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void operator()(_Tp* __p) const {std::__ndk1::return_temporary_buffer(__p);}
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = std::__ndk1::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__ndk1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{



    if (__len == 2)
    {
        swap(*__first, *__last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            swap(*__first, *__m);
            swap(*__m, *__last);
            return __last;
        }
        swap(*__m, *__last);
        swap(*__first, *__m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


        value_type* __t = __p.first;
        ::new(__t) value_type(std::__ndk1::move(*__first));
        __d.__incr((value_type*)0);
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = std::__ndk1::move(*__i);
                ++__first;
            }
            else
            {
                ::new(__t) value_type(std::__ndk1::move(*__i));
                __d.__incr((value_type*)0);
                ++__t;
            }
        }

        *__first = std::__ndk1::move(*__i);
        __i = ++__first;


        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)
            *__i = std::__ndk1::move(*__t2);

        return __first;
    }


    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    std::__ndk1::advance(__m, __len2);



    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }


    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }


    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


    return std::__ndk1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;

    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }


    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));




    difference_type __len = std::__ndk1::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
        __p = std::__ndk1::get_temporary_buffer<value_type>(__len);
        __h.reset(__p.first);
    }
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>
                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Compare>
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__ndk1::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _ForwardIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__ndk1::is_sorted_until(__first, __last, __comp) == __last;
}

template<class _ForwardIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::__ndk1::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}





template <class _Compare, class _ForwardIterator>
unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
{
    unsigned __r = 0;
    if (!__c(*__y, *__x))
    {
        if (!__c(*__z, *__y))
            return __r;

        swap(*__y, *__z);
        __r = 1;
        if (__c(*__y, *__x))
        {
            swap(*__x, *__y);
            __r = 2;
        }
        return __r;
    }
    if (__c(*__z, *__y))
    {
        swap(*__x, *__z);
        __r = 1;
        return __r;
    }
    swap(*__x, *__y);
    __r = 1;
    if (__c(*__z, *__y))
    {
        swap(*__y, *__z);
        __r = 2;
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _Compare __c)
{
    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
    if (__c(*__x4, *__x3))
    {
        swap(*__x3, *__x4);
        ++__r;
        if (__c(*__x3, *__x2))
        {
            swap(*__x2, *__x3);
            ++__r;
            if (__c(*__x2, *__x1))
            {
                swap(*__x1, *__x2);
                ++__r;
            }
        }
    }
    return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)
{
    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
    if (__c(*__x5, *__x4))
    {
        swap(*__x4, *__x5);
        ++__r;
        if (__c(*__x4, *__x3))
        {
            swap(*__x3, *__x4);
            ++__r;
            if (__c(*__x3, *__x2))
            {
                swap(*__x2, *__x3);
                ++__r;
                if (__c(*__x2, *__x1))
                {
                    swap(*__x1, *__x2);
                    ++__r;
                }
            }
        }
    }
    return __r;
}


template <class _Compare, class _BirdirectionalIterator>
void
__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    _BirdirectionalIterator __lm1 = __last;
    for (--__lm1; __first != __lm1; ++__first)
    {
        _BirdirectionalIterator __i = std::__ndk1::min_element<_BirdirectionalIterator,
                                                        typename add_lvalue_reference<_Compare>::type>
                                                       (__first, __last, __comp);
        if (__i != __first)
            swap(*__first, *__i);
    }
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first != __last)
    {
        _BirdirectionalIterator __i = __first;
        for (++__i; __i != __last; ++__i)
        {
            _BirdirectionalIterator __j = __i;
            value_type __t(std::__ndk1::move(*__j));
            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
                *__j = std::__ndk1::move(*__k);
            *__j = std::__ndk1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__ndk1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__ndk1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__ndk1::move(__t);
        }
        __j = __i;
    }
}

template <class _Compare, class _RandomAccessIterator>
bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    switch (__last - __first)
    {
    case 0:
    case 1:
        return true;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return true;
    case 3:
        std::__ndk1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        return true;
    case 4:
        std::__ndk1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        return true;
    case 5:
        std::__ndk1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        return true;
    }
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    _RandomAccessIterator __j = __first+2;
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    const unsigned __limit = 8;
    unsigned __count = 0;
    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)
    {
        if (__comp(*__i, *__j))
        {
            value_type __t(std::__ndk1::move(*__i));
            _RandomAccessIterator __k = __j;
            __j = __i;
            do
            {
                *__j = std::__ndk1::move(*__k);
                __j = __k;
            } while (__j != __first && __comp(__t, *--__k));
            *__j = std::__ndk1::move(__t);
            if (++__count == __limit)
                return ++__i == __last;
        }
        __j = __i;
    }
    return true;
}

template <class _Compare, class _BirdirectionalIterator>
void
__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)
{
    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
    if (__first1 != __last1)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
        value_type* __last2 = __first2;
        ::new(__last2) value_type(std::__ndk1::move(*__first1));
        __d.__incr((value_type*)0);
        for (++__last2; ++__first1 != __last1; ++__last2)
        {
            value_type* __j2 = __last2;
            value_type* __i2 = __j2;
            if (__comp(*__first1, *--__i2))
            {
                ::new(__j2) value_type(std::__ndk1::move(*__i2));
                __d.__incr((value_type*)0);
                for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
                    *__j2 = std::__ndk1::move(*__i2);
                *__j2 = std::__ndk1::move(*__first1);
            }
            else
            {
                ::new(__j2) value_type(std::__ndk1::move(*__first1));
                __d.__incr((value_type*)0);
            }
        }
        __h.release();
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&
                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;
    while (true)
    {
    __restart:
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            std::__ndk1::__sort3<_Compare>(__first, __first+1, --__last, __comp);
            return;
        case 4:
            std::__ndk1::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
            return;
        case 5:
            std::__ndk1::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
            return;
        }
        if (__len <= __limit)
        {
            std::__ndk1::__insertion_sort_3<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first;
        _RandomAccessIterator __lm1 = __last;
        --__lm1;
        unsigned __n_swaps;
        {
        difference_type __delta;
        if (__len >= 1000)
        {
            __delta = __len/2;
            __m += __delta;
            __delta /= 2;
            __n_swaps = std::__ndk1::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);
        }
        else
        {
            __delta = __len/2;
            __m += __delta;
            __n_swaps = std::__ndk1::__sort3<_Compare>(__first, __m, __lm1, __comp);
        }
        }



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }



                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }

        ++__i;


        if (__i < __j)
        {


            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i > __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }


        if (__n_swaps == 0)
        {
            bool __fs = std::__ndk1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
            if (std::__ndk1::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
            {
                if (__fs)
                    return;
                __last = __i;
                continue;
            }
            else
            {
                if (__fs)
                {
                    __first = ++__i;
                    continue;
                }
            }
        }

        if (__i - __first < __last - __i)
        {
            std::__ndk1::__sort<_Compare>(__first, __i, __comp);

            __first = ++__i;
        }
        else
        {
            std::__ndk1::__sort<_Compare>(__i+1, __last, __comp);

            __last = __i;
        }
    }
}


template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__ndk1::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(_Tp** __first, _Tp** __last)
{
    std::__ndk1::sort((size_t*)__first, (size_t*)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)
{
    std::__ndk1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)
{
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    std::__ndk1::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);
}












































template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__ndk1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__ndk1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__ndk1::lower_bound(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__ndk1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__ndk1::advance(__m, __l2);
        if (__comp(__value_, *__m))
            __len = __l2;
        else
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
    }
    return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__ndk1::upper_bound(__first, __last, __value_,
                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::__ndk1::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = __len / 2;
        _ForwardIterator __m = __first;
        std::__ndk1::advance(__m, __l2);
        if (__comp(*__m, __value_))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else if (__comp(__value_, *__m))
        {
            __last = __m;
            __len = __l2;
        }
        else
        {
            _ForwardIterator __mp1 = __m;
            return pair<_ForwardIterator, _ForwardIterator>
                   (
                      __lower_bound<_Compare>(__first, __m, __value_, __comp),
                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)
                   );
        }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__ndk1::equal_range(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{
    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
    return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)
{
    return std::__ndk1::binary_search(__first, __last, __value_,
                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__ndk1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::__ndk1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__ndk1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}



template <class _Compare, class _BidirectionalIterator>
void
__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__ndk1::move(*__i));
        __merge<_Compare>(move_iterator<value_type*>(__buff),
                          move_iterator<value_type*>(__p),
                          move_iterator<_BidirectionalIterator>(__middle),
                          move_iterator<_BidirectionalIterator>(__last),
                          __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)
            ::new(__p) value_type(std::__ndk1::move(*__i));
        typedef reverse_iterator<_BidirectionalIterator> _RBi;
        typedef reverse_iterator<value_type*> _Rv;
        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),
                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),
                _RBi(__last), __negate<_Compare>(__comp));
    }
}

template <class _Compare, class _BidirectionalIterator>
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {

        if (__len2 == 0)
            return;

        for (; true; ++__first, --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
        if (__len1 <= __buff_size || __len2 <= __buff_size)
        {
            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);
            return;
        }
# 4419 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/algorithm" 3
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;

        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            std::__ndk1::advance(__m2, __len21);
            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
            __len11 = std::__ndk1::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {

                swap(*__first, *__middle);
                return;
            }

            __len11 = __len1 / 2;
            __m1 = __first;
            std::__ndk1::advance(__m1, __len11);
            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
            __len21 = std::__ndk1::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;


        __middle = std::__ndk1::rotate(__m1, __middle, __m2);


        if (__len11 + __len21 < __len12 + __len22)
        {
            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);

            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);

            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}

template <class _Tp>
struct __inplace_merge_switch
{
    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;
};

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = std::__ndk1::distance(__first, __middle);
    difference_type __len2 = std::__ndk1::distance(__middle, __last);
    difference_type __buf_size = std::__ndk1::min(__len1, __len2);
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)
    {
        __buf = std::__ndk1::get_temporary_buffer<value_type>(__buf_size);
        __h.reset(__buf.first);
    }






    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return std::__ndk1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,
                                            __buf.first, __buf.second);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::__ndk1::inplace_merge(__first, __middle, __last,
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__ndk1::move(*__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))
                ::new (__result) value_type(std::__ndk1::move(*__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new (__result) value_type(std::__ndk1::move(*__first2));
            __d.__incr((value_type*)0);
            ++__first2;
        }
        else
        {
            ::new (__result) value_type(std::__ndk1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first1;
        }
    }
}

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, ++__result)
                *__result = std::__ndk1::move(*__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = std::__ndk1::move(*__first2);
            ++__first2;
        }
        else
        {
            *__result = std::__ndk1::move(*__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, ++__result)
        *__result = std::__ndk1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new(__first2) value_type(std::__ndk1::move(*__first1));
        return;
    case 2:
       __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
         if (__comp(*--__last1, *__first1))
        {
            ::new(__first2) value_type(std::__ndk1::move(*__last1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__ndk1::move(*__first1));
        }
        else
        {
            ::new(__first2) value_type(std::__ndk1::move(*__first1));
            __d.__incr((value_type*)0);
            ++__first2;
            ::new(__first2) value_type(std::__ndk1::move(*__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            swap(*__first, *__last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __insertion_sort<_Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)0);
        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)0);
        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





        return;
    }
    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    pair<value_type*, ptrdiff_t> __buf(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        __buf = std::__ndk1::get_temporary_buffer<value_type>(__len);
        __h.reset(__buf.first);
    }





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__ndk1::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename std::__ndk1::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__ndk1::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__ndk1::is_heap_until(__first, __last, __comp) == __last;
}

template<class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__ndk1::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__push_heap_front(_RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp,
                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        difference_type __p = 0;
        _RandomAccessIterator __pp = __first;
        difference_type __c = 2;
        _RandomAccessIterator __cp = __first + __c;
        if (__c == __len || __comp(*__cp, *(__cp - 1)))
        {
            --__c;
            --__cp;
        }
        if (__comp(*__pp, *__cp))
        {
            value_type __t(std::__ndk1::move(*__pp));
            do
            {
                *__pp = std::__ndk1::move(*__cp);
                __pp = __cp;
                __p = __c;
                __c = (__p + 1) * 2;
                if (__c > __len)
                    break;
                __cp = __first + __c;
                if (__c == __len || __comp(*__cp, *(__cp - 1)))
                {
                    --__c;
                    --__cp;
                }
            } while (__comp(__t, *__cp));
            *__pp = std::__ndk1::move(__t);
        }
    }
}

template <class _Compare, class _RandomAccessIterator>
void
__push_heap_back(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (__len > 1)
    {
        __len = (__len - 2) / 2;
        _RandomAccessIterator __ptr = __first + __len;
        if (__comp(*__ptr, *--__last))
        {
            value_type __t(std::__ndk1::move(*__last));
            do
            {
                *__last = std::__ndk1::move(*__ptr);
                __last = __ptr;
                if (__len == 0)
                    break;
                __len = (__len - 1) / 2;
                __ptr = __first + __len;
            } while (__comp(*__ptr, __t));
            *__last = std::__ndk1::move(__t);
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __push_heap_back<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__ndk1::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    if (__len > 1)
    {
        swap(*__first, *--__last);
        __push_heap_front<_Compare>(__first, __last, __comp, __len-1);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__ndk1::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __n = __last - __first;
    if (__n > 1)
    {
        __last = __first;
        ++__last;
        for (difference_type __i = 1; __i < __n;)
            __push_heap_back<_Compare>(__first, ++__last, __comp, ++__i);
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __make_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__ndk1::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
        __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __sort_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    std::__ndk1::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
    __make_heap<_Compare>(__first, __middle, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)
    {
        if (__comp(*__i, *__first))
        {
            swap(*__i, *__first);
            __push_heap_front<_Compare>(__first, __middle, __comp, __len);
        }
    }
    __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::__ndk1::partial_sort(__first, __middle, __last,
                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
    _RandomAccessIterator __r = __result_first;
    if (__r != __result_last)
    {
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = 0;
        for (; __first != __last && __r != __result_last; ++__first, ++__r, ++__len)
            *__r = *__first;
        __make_heap<_Compare>(__result_first, __r, __comp);
        for (; __first != __last; ++__first)
            if (__comp(*__first, *__result_first))
            {
                *__result_first = *__first;
                __push_heap_front<_Compare>(__result_first, __r, __comp, __len);
            }
        __sort_heap<_Compare>(__result_first, __r, __comp);
    }
    return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);

}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::__ndk1::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
    __restart:
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                swap(*__first, *__last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__ndk1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            __selection_sort<_Compare>(__first, __last, __comp);
            return;
        }

        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__ndk1::__sort3<_Compare>(__first, __m, --__lm1, __comp);



        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;



        if (!__comp(*__i, *__m))
        {


            while (true)
            {
                if (__i == --__j)
                {


                    ++__i;
                    __j = __last;
                    if (!__comp(*__first, *--__j))
                    {
                        while (true)
                        {
                            if (__i == __j)
                                return;
                            if (__comp(*__first, *__i))
                            {
                                swap(*__i, *__j);
                                ++__n_swaps;
                                ++__i;
                                break;
                            }
                            ++__i;
                        }
                    }

                    if (__i == __j)
                        return;
                    while (true)
                    {
                        while (!__comp(*__first, *__i))
                            ++__i;
                        while (__comp(*__first, *--__j))
                            ;
                        if (__i >= __j)
                            break;
                        swap(*__i, *__j);
                        ++__n_swaps;
                        ++__i;
                    }


                    if (__nth < __i)
                        return;


                    __first = __i;
                    goto __restart;
                }
                if (__comp(*__j, *__m))
                {
                    swap(*__i, *__j);
                    ++__n_swaps;
                    break;
                }
            }
        }
        ++__i;


        if (__i < __j)
        {

            while (true)
            {

                while (__comp(*__i, *__m))
                    ++__i;

                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                swap(*__i, *__j);
                ++__n_swaps;


                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }

        if (__i != __m && __comp(*__m, *__i))
        {
            swap(*__i, *__m);
            ++__n_swaps;
        }

        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {

            if (__nth < __i)
            {

                __j = __m = __first;
                while (++__j != __i)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
            else
            {

                __j = __m = __i;
                while (++__j != __last)
                {
                    if (__comp(*__j, *__m))

                        goto not_sorted;
                    __m = __j;
                }

                return;
            }
        }
not_sorted:

        if (__nth < __i)
        {

            __last = __i;
        }
        else
        {

            __first = ++__i;
        }
    }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
{
    std::__ndk1::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
           _Compare __comp)
{
    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
         _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__ndk1::includes(__first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_union(_InputIterator1 __first1, _InputIterator1 __last1,
            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::__ndk1::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            if (!__comp(*__first1, *__first2))
                ++__first2;
            ++__first1;
        }
    }
    return std::__ndk1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__ndk1::set_union(__first1, __last1, __first2, __last2, __result,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1 && __first2 != __last2)
    {
        if (__comp(*__first1, *__first2))
            ++__first1;
        else
        {
            if (!__comp(*__first2, *__first1))
            {
                *__result = *__first1;
                ++__result;
                ++__first1;
            }
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__ndk1::set_intersection(__first1, __last1, __first2, __last2, __result,
                                  __less<typename iterator_traits<_InputIterator1>::value_type,
                                         typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__ndk1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (!__comp(*__first2, *__first1))
                ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__ndk1::set_difference(__first1, __last1, __first2, __last2, __result,
                                __less<typename iterator_traits<_InputIterator1>::value_type,
                                       typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    while (__first1 != __last1)
    {
        if (__first2 == __last2)
            return std::__ndk1::copy(__first1, __last1, __result);
        if (__comp(*__first1, *__first2))
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else
        {
            if (__comp(*__first2, *__first1))
            {
                *__result = *__first2;
                ++__result;
            }
            else
                ++__first1;
            ++__first2;
        }
    }
    return std::__ndk1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    return std::__ndk1::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                                 typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::__ndk1::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*__i, *--__j))
                ;
            swap(*__i, *__j);
            std::__ndk1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__ndk1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __next_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__ndk1::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
    _BidirectionalIterator __i = __last;
    if (__first == __last || __first == --__i)
        return false;
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last;
            while (!__comp(*--__j, *__i))
                ;
            swap(*__i, *__j);
            std::__ndk1::reverse(__ip1, __last);
            return true;
        }
        if (__i == __first)
        {
            std::__ndk1::reverse(__first, __last);
            return false;
        }
    }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{





    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
    return __prev_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::__ndk1::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_left(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_integral<_Tp>::value,
    _Tp
>::type
__rotate_right(_Tp __t, _Tp __n = 1)
{
    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * 8 - 1);
    __n &= __bits;
    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));
}

} }
# 19 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cmath" 1 3
# 301 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cmath" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/math.h" 1 3
# 31 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/math.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/math.h" 1 3
# 21 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/math.h" 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include-fixed/limits.h" 1 3 4
# 34 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include-fixed/limits.h" 3 4
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include-fixed/syslimits.h" 1 3 4






# 1 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include-fixed/limits.h" 1 3 4
# 168 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include-fixed/limits.h" 3 4
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/limits.h" 1 3 4
# 86 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/limits.h" 3 4
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/limits.h" 1 3 4
# 30 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/limits.h" 3 4
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/linux/limits.h" 1 3 4
# 31 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/limits.h" 2 3 4
# 87 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/limits.h" 2 3 4


# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/sys/syslimits.h" 1 3 4
# 90 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/limits.h" 2 3 4
# 169 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include-fixed/limits.h" 2 3 4
# 8 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include-fixed/syslimits.h" 2 3 4
# 35 "/data/data/com.n0n3m4.droidc/files/gcc/lib/gcc/aarch64-linux-android/7.2.0/include-fixed/limits.h" 2 3 4
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/math.h" 2 3

extern "C" {
#pragma GCC visibility push(default)




extern const union __infinity_un {
 unsigned char __uc[8];
 double __ud;
} __infinity;

extern const union __nan_un {
 unsigned char __uc[sizeof(float)];
 float __uf;
} __nan;
# 129 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/math.h" 3
typedef double __double_t;
typedef __double_t double_t;
typedef float __float_t;
typedef __float_t float_t;
# 154 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/math.h" 3
extern int signgam;
# 175 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/math.h" 3
int __fpclassifyd(double) __attribute__((__const__));
int __fpclassifyf(float) __attribute__((__const__));
int __fpclassifyl(long double) __attribute__((__const__));
int __isfinitef(float) __attribute__((__const__));
int __isfinite(double) __attribute__((__const__));
int __isfinitel(long double) __attribute__((__const__));
int __isinff(float) __attribute__((__const__));
int __isinfl(long double) __attribute__((__const__));
int __isnanf(float) __attribute__((__const__));
int __isnanl(long double) __attribute__((__const__));
int __isnormalf(float) __attribute__((__const__));
int __isnormal(double) __attribute__((__const__));
int __isnormall(long double) __attribute__((__const__));
int __signbit(double) __attribute__((__const__));
int __signbitf(float) __attribute__((__const__));
int __signbitl(long double) __attribute__((__const__));

double acos(double) ;
double asin(double) ;
double atan(double) ;
double atan2(double, double) ;
double cos(double) ;
double sin(double) ;
double tan(double) ;

double cosh(double) ;
double sinh(double) ;
double tanh(double) ;

double exp(double) ;
double frexp(double, int *) ;
double ldexp(double, int) ;
double log(double) ;
double log10(double) ;
double modf(double, double *) ;

double pow(double, double) ;
double sqrt(double) ;

double ceil(double) ;
double fabs(double) __attribute__((__const__));
double floor(double) ;
double fmod(double, double) ;





double acosh(double) ;
double asinh(double) ;
double atanh(double) ;
double cbrt(double) ;
double erf(double) ;
double erfc(double) ;
double exp2(double) ;
double expm1(double) ;
double fma(double, double, double) ;
double hypot(double, double) ;
int ilogb(double) __attribute__((__const__));
int (isinf)(double) __attribute__((__const__));
int (isnan)(double) __attribute__((__const__));
double lgamma(double) ;
long long llrint(double) ;
long long llround(double) ;
double log1p(double) ;
double log2(double) ;
double logb(double) ;
long lrint(double) ;
long lround(double) ;
double nan(const char *) __attribute__((__const__));
double nextafter(double, double) ;
double remainder(double, double) ;
double remquo(double, double, int *) ;
double rint(double) ;



double j0(double) ;
double j1(double) ;
double jn(int, double) ;
double y0(double) ;
double y1(double) ;
double yn(int, double) ;


double gamma(double) ;



double scalb(double, double) ;




double copysign(double, double) __attribute__((__const__));
double fdim(double, double) ;
double fmax(double, double) __attribute__((__const__));
double fmin(double, double) __attribute__((__const__));
double nearbyint(double) ;
double round(double) ;
double scalbln(double, long) ;
double scalbn(double, int) ;
double tgamma(double) ;
double trunc(double) ;






double drem(double, double) ;
int finite(double) __attribute__((__const__));
int isnanf(float) __attribute__((__const__));
long double significandl(long double) ;





double gamma_r(double, int *) ;
double lgamma_r(double, int *) ;




double significand(double) ;




float acosf(float) ;
float asinf(float) ;
float atanf(float) ;
float atan2f(float, float) ;
float cosf(float) ;
float sinf(float) ;
float tanf(float) ;

float coshf(float) ;
float sinhf(float) ;
float tanhf(float) ;

float exp2f(float) ;
float expf(float) ;
float expm1f(float) ;
float frexpf(float, int *) ;
int ilogbf(float) __attribute__((__const__));
float ldexpf(float, int) ;
float log10f(float) ;
float log1pf(float) ;
float log2f(float) ;
float logf(float) ;
float modff(float, float *) ;

float powf(float, float) ;
float sqrtf(float) ;

float ceilf(float) ;
float fabsf(float) __attribute__((__const__));
float floorf(float) ;
float fmodf(float, float) ;
float roundf(float) ;

float erff(float) ;
float erfcf(float) ;
float hypotf(float, float) ;
float lgammaf(float) ;
float tgammaf(float) ;

float acoshf(float) ;
float asinhf(float) ;
float atanhf(float) ;
float cbrtf(float) ;
float logbf(float) ;
float copysignf(float, float) __attribute__((__const__));
long long llrintf(float) ;
long long llroundf(float) ;
long lrintf(float) ;
long lroundf(float) ;
float nanf(const char *) __attribute__((__const__));
float nearbyintf(float) ;
float nextafterf(float, float) ;
float remainderf(float, float) ;
float remquof(float, float, int *) ;
float rintf(float) ;
float scalblnf(float, long) ;
float scalbnf(float, int) ;
float truncf(float) ;

float fdimf(float, float) ;
float fmaf(float, float, float) ;
float fmaxf(float, float) __attribute__((__const__));
float fminf(float, float) __attribute__((__const__));






float dremf(float, float) ;
int finitef(float) __attribute__((__const__));
float gammaf(float) ;
float j0f(float) ;
float j1f(float) ;
float jnf(int, float) ;
float scalbf(float, float) ;
float y0f(float) ;
float y1f(float) ;
float ynf(int, float) ;






float gammaf_r(float, int *) ;
float lgammaf_r(float, int *) ;




float significandf(float) ;






long double acoshl(long double) ;
long double acosl(long double) ;
long double asinhl(long double) ;
long double asinl(long double) ;
long double atan2l(long double, long double) ;
long double atanhl(long double) ;
long double atanl(long double) ;
long double cbrtl(long double) ;
long double ceill(long double) ;
long double copysignl(long double, long double) __attribute__((__const__));
long double coshl(long double) ;
long double cosl(long double) ;
long double erfcl(long double) ;
long double erfl(long double) ;
long double exp2l(long double) ;
long double expl(long double) ;
long double expm1l(long double) ;
long double fabsl(long double) __attribute__((__const__));
long double fdiml(long double, long double) ;
long double floorl(long double) ;
long double fmal(long double, long double, long double) ;
long double fmaxl(long double, long double) __attribute__((__const__));
long double fminl(long double, long double) __attribute__((__const__));
long double fmodl(long double, long double) ;
long double frexpl(long double value, int *) ;
long double hypotl(long double, long double) ;
int ilogbl(long double) __attribute__((__const__));
long double ldexpl(long double, int) ;
long double lgammal(long double) ;
long long llrintl(long double) ;
long long llroundl(long double) ;
long double log10l(long double) ;
long double log1pl(long double) ;
long double log2l(long double) ;
long double logbl(long double) ;
long double logl(long double) ;
long lrintl(long double) ;
long lroundl(long double) ;
long double modfl(long double, long double *) ;
long double nanl(const char *) __attribute__((__const__));
long double nearbyintl(long double) ;
long double nextafterl(long double, long double) ;
double nexttoward(double, long double) ;
float nexttowardf(float, long double) ;
long double nexttowardl(long double, long double) ;
long double powl(long double, long double) ;
long double remainderl(long double, long double) ;
long double remquol(long double, long double, int *) ;
long double rintl(long double) ;
long double roundl(long double) ;
long double scalblnl(long double, long) ;
long double scalbnl(long double, int) ;
long double sinhl(long double) ;
long double sinl(long double) ;
long double sqrtl(long double) ;
long double tanhl(long double) ;
long double tanl(long double) ;
long double tgammal(long double) ;
long double truncl(long double) ;




void sincos(double, double*, double*) ;
void sincosf(float, float*, float*) ;
void sincosl(long double, long double*, long double*) ;




double __builtin_acos(double) ;
double __builtin_asin(double) ;
double __builtin_atan(double) ;
double __builtin_atan2(double, double) ;
double __builtin_cos(double) ;
double __builtin_sin(double) ;
double __builtin_tan(double) ;

double __builtin_cosh(double) ;
double __builtin_sinh(double) ;
double __builtin_tanh(double) ;

double __builtin_exp(double) ;
double __builtin_frexp(double, int *) ;
double __builtin_ldexp(double, int) ;
double __builtin_log(double) ;
double __builtin_log10(double) ;
double __builtin_modf(double, double *) ;

double __builtin_pow(double, double) ;
double __builtin_sqrt(double) ;

double __builtin_ceil(double) ;
double __builtin_fabs(double) __attribute__((__const__));
double __builtin_floor(double) ;
double __builtin_fmod(double, double) ;





double __builtin_acosh(double) ;
double __builtin_asinh(double) ;
double __builtin_atanh(double) ;
double __builtin_cbrt(double) ;
double __builtin_erf(double) ;
double __builtin_erfc(double) ;
double __builtin_exp2(double) ;
double __builtin_expm1(double) ;
double __builtin_fma(double, double, double) ;
double __builtin_hypot(double, double) ;
int __builtin_ilogb(double) __attribute__((__const__));


int __builtin_isinf(double) __attribute__((__const__));
int __builtin_isnan(double) __attribute__((__const__));

double __builtin_lgamma(double) ;
long long __builtin_llrint(double) ;
long long __builtin_llround(double) ;
double __builtin_log1p(double) ;
double __builtin_log2(double) ;
double __builtin_logb(double) ;
long __builtin_lrint(double) ;
long __builtin_lround(double) ;
double __builtin_nan(const char *) __attribute__((__const__));
double __builtin_nextafter(double, double) ;
double __builtin_remainder(double, double) ;
double __builtin_remquo(double, double, int *) ;
double __builtin_rint(double) ;



double __builtin_j0(double) ;
double __builtin_j1(double) ;
double __builtin_jn(int, double) ;
double __builtin_y0(double) ;
double __builtin_y1(double) ;
double __builtin_yn(int, double) ;


double __builtin_gamma(double) ;



double __builtin_scalb(double, double) ;




double __builtin_copysign(double, double) __attribute__((__const__));
double __builtin_fdim(double, double) ;
double __builtin_fmax(double, double) __attribute__((__const__));
double __builtin_fmin(double, double) __attribute__((__const__));
double __builtin_nearbyint(double) ;
double __builtin_round(double) ;
double __builtin_scalbln(double, long) ;
double __builtin_scalbn(double, int) ;
double __builtin_tgamma(double) ;
double __builtin_trunc(double) ;






double __builtin_drem(double, double) ;
int __builtin_finite(double) __attribute__((__const__));
int __builtin_isnanf(float) __attribute__((__const__));
long double significandl(long double) ;





double __builtin_gamma_r(double, int *) ;
double __builtin_lgamma_r(double, int *) ;




double __builtin_significand(double) ;




float __builtin_acosf(float) ;
float __builtin_asinf(float) ;
float __builtin_atanf(float) ;
float __builtin_atan2f(float, float) ;
float __builtin_cosf(float) ;
float __builtin_sinf(float) ;
float __builtin_tanf(float) ;

float __builtin_coshf(float) ;
float __builtin_sinhf(float) ;
float __builtin_tanhf(float) ;

float __builtin_exp2f(float) ;
float __builtin_expf(float) ;
float __builtin_expm1f(float) ;
float __builtin_frexpf(float, int *) ;
int __builtin_ilogbf(float) __attribute__((__const__));
float __builtin_ldexpf(float, int) ;
float __builtin_log10f(float) ;
float __builtin_log1pf(float) ;
float __builtin_log2f(float) ;
float __builtin_logf(float) ;
float __builtin_modff(float, float *) ;

float __builtin_powf(float, float) ;
float __builtin_sqrtf(float) ;

float __builtin_ceilf(float) ;
float __builtin_fabsf(float) __attribute__((__const__));
float __builtin_floorf(float) ;
float __builtin_fmodf(float, float) ;
float __builtin_roundf(float) ;

float __builtin_erff(float) ;
float __builtin_erfcf(float) ;
float __builtin_hypotf(float, float) ;
float __builtin_lgammaf(float) ;
float __builtin_tgammaf(float) ;

float __builtin_acoshf(float) ;
float __builtin_asinhf(float) ;
float __builtin_atanhf(float) ;
float __builtin_cbrtf(float) ;
float __builtin_logbf(float) ;
float __builtin_copysignf(float, float) __attribute__((__const__));
long long __builtin_llrintf(float) ;
long long __builtin_llroundf(float) ;
long __builtin_lrintf(float) ;
long __builtin_lroundf(float) ;
float __builtin_nanf(const char *) __attribute__((__const__));
float __builtin_nearbyintf(float) ;
float __builtin_nextafterf(float, float) ;
float __builtin_remainderf(float, float) ;
float __builtin_remquof(float, float, int *) ;
float __builtin_rintf(float) ;
float __builtin_scalblnf(float, long) ;
float __builtin_scalbnf(float, int) ;
float __builtin_truncf(float) ;

float __builtin_fdimf(float, float) ;
float __builtin_fmaf(float, float, float) ;
float __builtin_fmaxf(float, float) __attribute__((__const__));
float __builtin_fminf(float, float) __attribute__((__const__));






float __builtin_dremf(float, float) ;
int __builtin_finitef(float) __attribute__((__const__));
float __builtin_gammaf(float) ;
float __builtin_j0f(float) ;
float __builtin_j1f(float) ;
float __builtin_jnf(int, float) ;
float __builtin_scalbf(float, float) ;
float __builtin_y0f(float) ;
float __builtin_y1f(float) ;
float __builtin_ynf(int, float) ;






float __builtin_gammaf_r(float, int *) ;
float __builtin_lgammaf_r(float, int *) ;




float __builtin_significandf(float) ;






long double __builtin_acoshl(long double) ;
long double __builtin_acosl(long double) ;
long double __builtin_asinhl(long double) ;
long double __builtin_asinl(long double) ;
long double __builtin_atan2l(long double, long double) ;
long double __builtin_atanhl(long double) ;
long double __builtin_atanl(long double) ;
long double __builtin_cbrtl(long double) ;
long double __builtin_ceill(long double) ;
long double __builtin_copysignl(long double, long double) __attribute__((__const__));
long double __builtin_coshl(long double) ;
long double __builtin_cosl(long double) ;
long double __builtin_erfcl(long double) ;
long double __builtin_erfl(long double) ;
long double __builtin_exp2l(long double) ;
long double __builtin_expl(long double) ;
long double __builtin_expm1l(long double) ;
long double __builtin_fabsl(long double) __attribute__((__const__));
long double __builtin_fdiml(long double, long double) ;
long double __builtin_floorl(long double) ;
long double __builtin_fmal(long double, long double, long double) ;
long double __builtin_fmaxl(long double, long double) __attribute__((__const__));
long double __builtin_fminl(long double, long double) __attribute__((__const__));
long double __builtin_fmodl(long double, long double) ;
long double __builtin_frexpl(long double value, int *) ;
long double __builtin_hypotl(long double, long double) ;
int __builtin_ilogbl(long double) __attribute__((__const__));
long double __builtin_ldexpl(long double, int) ;
long double __builtin_lgammal(long double) ;
long long __builtin_llrintl(long double) ;
long long __builtin_llroundl(long double) ;
long double __builtin_log10l(long double) ;
long double __builtin_log1pl(long double) ;
long double __builtin_log2l(long double) ;
long double __builtin_logbl(long double) ;
long double __builtin_logl(long double) ;
long __builtin_lrintl(long double) ;
long __builtin_lroundl(long double) ;
long double __builtin_modfl(long double, long double *) ;
long double __builtin_nanl(const char *) __attribute__((__const__));
long double __builtin_nearbyintl(long double) ;
long double __builtin_nextafterl(long double, long double) ;
double __builtin_nexttoward(double, long double) ;
float __builtin_nexttowardf(float, long double) ;
long double __builtin_nexttowardl(long double, long double) ;
long double __builtin_powl(long double, long double) ;
long double __builtin_remainderl(long double, long double) ;
long double __builtin_remquol(long double, long double, int *) ;
long double __builtin_rintl(long double) ;
long double __builtin_roundl(long double) ;
long double __builtin_scalblnl(long double, long) ;
long double __builtin_scalbnl(long double, int) ;
long double __builtin_sinhl(long double) ;
long double __builtin_sinl(long double) ;
long double __builtin_sqrtl(long double) ;
long double __builtin_tanhl(long double) ;
long double __builtin_tanl(long double) ;
long double __builtin_tgammal(long double) ;
long double __builtin_truncl(long double) ;




void __builtin_sincos(double, double*, double*) ;
void __builtin_sincosf(float, float*, float*) ;
void __builtin_sincosl(long double, long double*, long double*) ;


#pragma GCC visibility pop
}
# 32 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/math.h" 2 3
# 302 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cmath" 2 3







       
# 310 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/cmath" 3






template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_signbit(_A1 __x) throw()
{
    return ((sizeof (__x) == sizeof (float)) ? __signbitf(__x) : (sizeof (__x) == sizeof (double)) ? __signbit(__x) : __signbitl(__x));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
signbit(_A1 __x) throw()
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
int
__libcpp_fpclassify(_A1 __x) throw()
{
    return ((sizeof (__x) == sizeof (float)) ? __fpclassifyf(__x) : (sizeof (__x) == sizeof (double)) ? __fpclassifyd(__x) : __fpclassifyl(__x));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, int>::type
fpclassify(_A1 __x) throw()
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isfinite(_A1 __x) throw()
{
    return ((sizeof (__x) == sizeof (float)) ? __isfinitef(__x) : (sizeof (__x) == sizeof (double)) ? __isfinite(__x) : __isfinitel(__x));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isfinite(_A1 __x) throw()
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isinf(_A1 __x) throw()
{
    return ((sizeof (__x) == sizeof (float)) ? __isinff(__x) : (sizeof (__x) == sizeof (double)) ? isinf(__x) : __isinfl(__x));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isinf(_A1 __x) throw()
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnan(_A1 __x) throw()
{
    return ((sizeof (__x) == sizeof (float)) ? __isnanf(__x) : (sizeof (__x) == sizeof (double)) ? isnan(__x) : __isnanl(__x));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnan(_A1 __x) throw()
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnormal(_A1 __x) throw()
{
    return ((sizeof (__x) == sizeof (float)) ? __isnormalf(__x) : (sizeof (__x) == sizeof (double)) ? __isnormal(__x) : __isnormall(__x));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnormal(_A1 __x) throw()
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__x);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreater(_A1 __x, _A2 __y) throw()
{
    return __builtin_isgreater((__x), (__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreaterequal(_A1 __x, _A2 __y) throw()
{
    return __builtin_isgreaterequal((__x), (__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isless(_A1 __x, _A2 __y) throw()
{
    return __builtin_isless((__x), (__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessequal(_A1 __x, _A2 __y) throw()
{
    return __builtin_islessequal((__x), (__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessgreater(_A1 __x, _A2 __y) throw()
{
    return __builtin_islessgreater((__x), (__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isunordered(_A1 __x, _A2 __y) throw()
{
    return __builtin_isunordered((__x), (__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__x, (type)__y);
}



namespace std { namespace __ndk1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;




inline __attribute__ ((__visibility__("hidden"), __always_inline__))
float
abs(float __x) throw() {return fabsf(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
double
abs(double __x) throw() {return fabs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long double
abs(long double __x) throw() {return fabsl(__x);}






using ::acos;
using ::acosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acos(float __x) throw() {return acosf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acos(long double __x) throw() {return acosl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acos(_A1 __x) throw() {return acos((double)__x);}



using ::asin;
using ::asinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asin(float __x) throw() {return asinf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asin(long double __x) throw() {return asinl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asin(_A1 __x) throw() {return asin((double)__x);}



using ::atan;
using ::atanf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan(float __x) throw() {return atanf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan(long double __x) throw() {return atanl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atan(_A1 __x) throw() {return atan((double)__x);}



using ::atan2;
using ::atan2f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan2(float __y, float __x) throw() {return atan2f(__y, __x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan2(long double __y, long double __x) throw() {return atan2l(__y, __x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
atan2(_A1 __y, _A2 __x) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return atan2((__result_type)__y, (__result_type)__x);
}



using ::ceil;
using ::ceilf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ceil(float __x) throw() {return ceilf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ceil(long double __x) throw() {return ceill(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ceil(_A1 __x) throw() {return ceil((double)__x);}



using ::cos;
using ::cosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cos(float __x) throw() {return cosf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cos(long double __x) throw() {return cosl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cos(_A1 __x) throw() {return cos((double)__x);}



using ::cosh;
using ::coshf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cosh(float __x) throw() {return coshf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cosh(long double __x) throw() {return coshl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cosh(_A1 __x) throw() {return cosh((double)__x);}




using ::exp;
using ::expf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp(float __x) throw() {return expf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp(long double __x) throw() {return expl(__x);}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp(_A1 __x) throw() {return exp((double)__x);}



using ::fabs;
using ::fabsf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fabs(float __x) throw() {return fabsf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fabs(long double __x) throw() {return fabsl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
fabs(_A1 __x) throw() {return fabs((double)__x);}



using ::floor;
using ::floorf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float floor(float __x) throw() {return floorf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double floor(long double __x) throw() {return floorl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
floor(_A1 __x) throw() {return floor((double)__x);}




using ::fmod;
using ::fmodf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmod(float __x, float __y) throw() {return fmodf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmod(long double __x, long double __y) throw() {return fmodl(__x, __y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmod(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return fmod((__result_type)__x, (__result_type)__y);
}




using ::frexp;
using ::frexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float frexp(float __x, int* __e) throw() {return frexpf(__x, __e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double frexp(long double __x, int* __e) throw() {return frexpl(__x, __e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
frexp(_A1 __x, int* __e) throw() {return frexp((double)__x, __e);}



using ::ldexp;
using ::ldexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ldexp(float __x, int __e) throw() {return ldexpf(__x, __e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ldexp(long double __x, int __e) throw() {return ldexpl(__x, __e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ldexp(_A1 __x, int __e) throw() {return ldexp((double)__x, __e);}




using ::log;
using ::logf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log(float __x) throw() {return logf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log(long double __x) throw() {return logl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log(_A1 __x) throw() {return log((double)__x);}




using ::log10;
using ::log10f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log10(float __x) throw() {return log10f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log10(long double __x) throw() {return log10l(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log10(_A1 __x) throw() {return log10((double)__x);}



using ::modf;
using ::modff;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float modf(float __x, float* __y) throw() {return modff(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double modf(long double __x, long double* __y) throw() {return modfl(__x, __y);}





using ::pow;
using ::powf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float pow(float __x, float __y) throw() {return powf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double pow(long double __x, long double __y) throw() {return powl(__x, __y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
pow(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return pow((__result_type)__x, (__result_type)__y);
}



using ::sin;
using ::sinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sin(float __x) throw() {return sinf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sin(long double __x) throw() {return sinl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sin(_A1 __x) throw() {return sin((double)__x);}



using ::sinh;
using ::sinhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sinh(float __x) throw() {return sinhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sinh(long double __x) throw() {return sinhl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sinh(_A1 __x) throw() {return sinh((double)__x);}




using ::sqrt;
using ::sqrtf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sqrt(float __x) throw() {return sqrtf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sqrt(long double __x) throw() {return sqrtl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sqrt(_A1 __x) throw() {return sqrt((double)__x);}



using ::tan;
using ::tanf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tan(float __x) throw() {return tanf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tan(long double __x) throw() {return tanl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tan(_A1 __x) throw() {return tan((double)__x);}



using ::tanh;
using ::tanhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tanh(float __x) throw() {return tanhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tanh(long double __x) throw() {return tanhl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tanh(_A1 __x) throw() {return tanh((double)__x);}




using ::acosh;
using ::acoshf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acosh(float __x) throw() {return acoshf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acosh(long double __x) throw() {return acoshl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acosh(_A1 __x) throw() {return acosh((double)__x);}





using ::asinh;
using ::asinhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asinh(float __x) throw() {return asinhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asinh(long double __x) throw() {return asinhl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asinh(_A1 __x) throw() {return asinh((double)__x);}





using ::atanh;
using ::atanhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atanh(float __x) throw() {return atanhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atanh(long double __x) throw() {return atanhl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atanh(_A1 __x) throw() {return atanh((double)__x);}





using ::cbrt;
using ::cbrtf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cbrt(float __x) throw() {return cbrtf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cbrt(long double __x) throw() {return cbrtl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cbrt(_A1 __x) throw() {return cbrt((double)__x);}




using ::copysign;
using ::copysignf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float copysign(float __x, float __y) throw() {return copysignf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double copysign(long double __x, long double __y) throw() {return copysignl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
copysign(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return copysign((__result_type)__x, (__result_type)__y);
}





using ::erf;
using ::erff;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erf(float __x) throw() {return erff(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erf(long double __x) throw() {return erfl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erf(_A1 __x) throw() {return erf((double)__x);}



using ::erfc;
using ::erfcf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erfc(float __x) throw() {return erfcf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erfc(long double __x) throw() {return erfcl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erfc(_A1 __x) throw() {return erfc((double)__x);}



using ::exp2;
using ::exp2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp2(float __x) throw() {return exp2f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp2(long double __x) throw() {return exp2l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp2(_A1 __x) throw() {return exp2((double)__x);}



using ::expm1;
using ::expm1f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float expm1(float __x) throw() {return expm1f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double expm1(long double __x) throw() {return expm1l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
expm1(_A1 __x) throw() {return expm1((double)__x);}



using ::fdim;
using ::fdimf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fdim(float __x, float __y) throw() {return fdimf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fdim(long double __x, long double __y) throw() {return fdiml(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fdim(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return fdim((__result_type)__x, (__result_type)__y);
}



using ::fmaf;
using ::fma;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fma(float __x, float __y, float __z) throw() {return fmaf(__x, __y, __z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fma(long double __x, long double __y, long double __z) throw() {return fmal(__x, __y, __z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    typename __promote<_A1, _A2, _A3>::type
>::type
fma(_A1 __x, _A2 __y, _A3 __z) throw()
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value &&
                      is_same<_A3, __result_type>::value)), "");
    return fma((__result_type)__x, (__result_type)__y, (__result_type)__z);
}



using ::fmax;
using ::fmaxf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmax(float __x, float __y) throw() {return fmaxf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmax(long double __x, long double __y) throw() {return fmaxl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmax(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return fmax((__result_type)__x, (__result_type)__y);
}



using ::fmin;
using ::fminf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmin(float __x, float __y) throw() {return fminf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmin(long double __x, long double __y) throw() {return fminl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmin(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return fmin((__result_type)__x, (__result_type)__y);
}



using ::hypot;
using ::hypotf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float hypot(float __x, float __y) throw() {return hypotf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double hypot(long double __x, long double __y) throw() {return hypotl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
hypot(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return hypot((__result_type)__x, (__result_type)__y);
}



using ::ilogb;
using ::ilogbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(float __x) throw() {return ilogbf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(long double __x) throw() {return ilogbl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, int>::type
ilogb(_A1 __x) throw() {return ilogb((double)__x);}



using ::lgamma;
using ::lgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float lgamma(float __x) throw() {return lgammaf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double lgamma(long double __x) throw() {return lgammal(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
lgamma(_A1 __x) throw() {return lgamma((double)__x);}




using ::llrint;
using ::llrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(float __x) throw() {return llrintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(long double __x) throw() {return llrintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llrint(_A1 __x) throw() {return llrint((double)__x);}



using ::llround;
using ::llroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(float __x) throw() {return llroundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(long double __x) throw() {return llroundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llround(_A1 __x) throw() {return llround((double)__x);}



using ::log1p;
using ::log1pf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log1p(float __x) throw() {return log1pf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log1p(long double __x) throw() {return log1pl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log1p(_A1 __x) throw() {return log1p((double)__x);}



using ::log2;
using ::log2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log2(float __x) throw() {return log2f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log2(long double __x) throw() {return log2l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log2(_A1 __x) throw() {return log2((double)__x);}



using ::logb;
using ::logbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float logb(float __x) throw() {return logbf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double logb(long double __x) throw() {return logbl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
logb(_A1 __x) throw() {return logb((double)__x);}



using ::lrint;
using ::lrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(float __x) throw() {return lrintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(long double __x) throw() {return lrintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lrint(_A1 __x) throw() {return lrint((double)__x);}



using ::lround;
using ::lroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(float __x) throw() {return lroundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(long double __x) throw() {return lroundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lround(_A1 __x) throw() {return lround((double)__x);}







using ::nan;
using ::nanf;







using ::nearbyint;
using ::nearbyintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nearbyint(float __x) throw() {return nearbyintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nearbyint(long double __x) throw() {return nearbyintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nearbyint(_A1 __x) throw() {return nearbyint((double)__x);}



using ::nextafter;
using ::nextafterf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nextafter(float __x, float __y) throw() {return nextafterf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nextafter(long double __x, long double __y) throw() {return nextafterl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
nextafter(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return nextafter((__result_type)__x, (__result_type)__y);
}



using ::nexttoward;
using ::nexttowardf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nexttoward(float __x, long double __y) throw() {return nexttowardf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nexttoward(long double __x, long double __y) throw() {return nexttowardl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nexttoward(_A1 __x, long double __y) throw() {return nexttoward((double)__x, __y);}



using ::remainder;
using ::remainderf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remainder(float __x, float __y) throw() {return remainderf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remainder(long double __x, long double __y) throw() {return remainderl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remainder(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return remainder((__result_type)__x, (__result_type)__y);
}



using ::remquo;
using ::remquof;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remquo(float __x, float __y, int* __z) throw() {return remquof(__x, __y, __z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remquo(long double __x, long double __y, int* __z) throw() {return remquol(__x, __y, __z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remquo(_A1 __x, _A2 __y, int* __z) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                      is_same<_A2, __result_type>::value)), "");
    return remquo((__result_type)__x, (__result_type)__y, __z);
}



using ::rint;
using ::rintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float rint(float __x) throw() {return rintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double rint(long double __x) throw() {return rintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
rint(_A1 __x) throw() {return rint((double)__x);}



using ::round;
using ::roundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float round(float __x) throw() {return roundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double round(long double __x) throw() {return roundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
round(_A1 __x) throw() {return round((double)__x);}



using ::scalbln;
using ::scalblnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbln(float __x, long __y) throw() {return scalblnf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbln(long double __x, long __y) throw() {return scalblnl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbln(_A1 __x, long __y) throw() {return scalbln((double)__x, __y);}



using ::scalbn;
using ::scalbnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbn(float __x, int __y) throw() {return scalbnf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbn(long double __x, int __y) throw() {return scalbnl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbn(_A1 __x, int __y) throw() {return scalbn((double)__x, __y);}



using ::tgamma;
using ::tgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tgamma(float __x) throw() {return tgammaf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tgamma(long double __x) throw() {return tgammal(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tgamma(_A1 __x) throw() {return tgamma((double)__x);}



using ::trunc;
using ::truncf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float trunc(float __x) throw() {return truncf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double trunc(long double __x) throw() {return truncl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
trunc(_A1 __x) throw() {return trunc((double)__x);}



using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;






} }
# 20 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 2 3

# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__undef_min_max" 1 3
# 22 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 2 3
# 30 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
       
# 31 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3


namespace std { namespace __ndk1 {

__attribute__ ((__visibility__("default")))
size_t __next_prime(size_t __n);

template <class _NodePtr>
struct __hash_node_base
{
    typedef __hash_node_base __first_node;

    _NodePtr __next_;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __hash_node_base() throw() : __next_(nullptr) {}
};

template <class _Tp, class _VoidPtr>
struct __hash_node
    : public __hash_node_base
             <
                 typename pointer_traits<_VoidPtr>::template



                     rebind<__hash_node<_Tp, _VoidPtr> >::other

             >
{
    typedef _Tp value_type;

    size_t __hash_;
    value_type __value_;
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__is_power2(size_t __bc)
{
    return __bc > 2 && !(__bc & (__bc - 1));
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__constrain_hash(size_t __h, size_t __bc)
{
    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) : __h % __bc;
}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
size_t
__next_pow2(size_t __n)
{
    return size_t(1) << (std::numeric_limits<size_t>::digits - __clz(__n-1));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;
template <class _ConstNodePtr> class __attribute__ ((__visibility__("default"))) __hash_const_iterator;
template <class _HashIterator> class __attribute__ ((__visibility__("default"))) __hash_map_iterator;
template <class _HashIterator> class __attribute__ ((__visibility__("default"))) __hash_map_const_iterator;
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    class __attribute__ ((__visibility__("default"))) unordered_map;

template <class _NodePtr>
class __attribute__ ((__visibility__("default"))) __hash_iterator
{
    typedef _NodePtr __node_pointer;

    __node_pointer __node_;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename pointer_traits<__node_pointer>::element_type::value_type value_type;
    typedef typename pointer_traits<__node_pointer>::difference_type difference_type;
    typedef value_type& reference;
    typedef typename pointer_traits<__node_pointer>::template



                     rebind<value_type>::other

                                                         pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __hash_iterator() throw()

    : __node_(nullptr)

    {



    }
# 152 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        reference operator*() const
        {




            return __node_->__value_;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        pointer operator->() const
        {




            return pointer_traits<pointer>::pointer_to(__node_->__value_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_iterator& operator++()
    {




        __node_ = __node_->__next_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_iterator operator++(int)
    {
        __hash_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)
        {return !(__x == __y);}

private:
# 208 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_iterator(__node_pointer __node) throw()
        : __node_(__node)
        {}


    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_map_iterator;
    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_multimap;
};

template <class _ConstNodePtr>
class __attribute__ ((__visibility__("default"))) __hash_const_iterator
{
    typedef _ConstNodePtr __node_pointer;

    __node_pointer __node_;

    typedef typename remove_const<
        typename pointer_traits<__node_pointer>::element_type
                                 >::type __node;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename __node::value_type value_type;
    typedef typename pointer_traits<__node_pointer>::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<const value_type>::other

                                                       pointer;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<__node>::other

                                                      __non_const_node_pointer;
    typedef __hash_iterator<__non_const_node_pointer> __non_const_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __hash_const_iterator() throw()

    : __node_(nullptr)

    {



    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_const_iterator(const __non_const_iterator& __x) throw()
        : __node_(__x.__node_)
    {



    }
# 299 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        reference operator*() const
        {




            return __node_->__value_;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        pointer operator->() const
        {




            return pointer_traits<pointer>::pointer_to(__node_->__value_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_const_iterator& operator++()
    {




        __node_ = __node_->__next_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_const_iterator operator++(int)
    {
        __hash_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)
        {return !(__x == __y);}

private:
# 355 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_const_iterator(__node_pointer __node) throw()
        : __node_(__node)
        {}


    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_map_const_iterator;
    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_multimap;
};

template <class _ConstNodePtr> class __attribute__ ((__visibility__("default"))) __hash_const_local_iterator;

template <class _NodePtr>
class __attribute__ ((__visibility__("default"))) __hash_local_iterator
{
    typedef _NodePtr __node_pointer;

    __node_pointer __node_;
    size_t __bucket_;
    size_t __bucket_count_;

    typedef pointer_traits<__node_pointer> __pointer_traits;
public:
    typedef forward_iterator_tag iterator_category;
    typedef typename __pointer_traits::element_type::value_type value_type;
    typedef typename __pointer_traits::difference_type difference_type;
    typedef value_type& reference;
    typedef typename __pointer_traits::template



            rebind<value_type>::other

                                                                pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __hash_local_iterator() throw()
    {



    }
# 431 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        reference operator*() const
        {




            return __node_->__value_;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        pointer operator->() const
        {




            return pointer_traits<pointer>::pointer_to(__node_->__value_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_local_iterator& operator++()
    {




        __node_ = __node_->__next_;
        if (__node_ != nullptr && __constrain_hash(__node_->__hash_, __bucket_count_) != __bucket_)
            __node_ = nullptr;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_local_iterator operator++(int)
    {
        __hash_local_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)
        {return !(__x == __y);}

private:
# 494 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_local_iterator(__node_pointer __node, size_t __bucket,
                          size_t __bucket_count) throw()
        : __node_(__node),
          __bucket_(__bucket),
          __bucket_count_(__bucket_count)
        {
            if (__node_ != nullptr)
                __node_ = __node_->__next_;
        }

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_const_local_iterator;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_map_iterator;
};

template <class _ConstNodePtr>
class __attribute__ ((__visibility__("default"))) __hash_const_local_iterator
{
    typedef _ConstNodePtr __node_pointer;

    __node_pointer __node_;
    size_t __bucket_;
    size_t __bucket_count_;

    typedef pointer_traits<__node_pointer> __pointer_traits;
    typedef typename __pointer_traits::element_type __node;
    typedef typename remove_const<__node>::type __non_const_node;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<__non_const_node>::other

                                                    __non_const_node_pointer;
    typedef __hash_local_iterator<__non_const_node_pointer>
                                                    __non_const_iterator;
public:
    typedef forward_iterator_tag iterator_category;
    typedef typename remove_const<
                        typename __pointer_traits::element_type::value_type
                     >::type value_type;
    typedef typename __pointer_traits::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename __pointer_traits::template



            rebind<const value_type>::other

                                                       pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__)) __hash_const_local_iterator() throw()
    {



    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_const_local_iterator(const __non_const_iterator& __x) throw()
        : __node_(__x.__node_),
          __bucket_(__x.__bucket_),
          __bucket_count_(__x.__bucket_count_)
    {



    }
# 596 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        reference operator*() const
        {




            return __node_->__value_;
        }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        pointer operator->() const
        {




            return pointer_traits<pointer>::pointer_to(__node_->__value_);
        }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_const_local_iterator& operator++()
    {




        __node_ = __node_->__next_;
        if (__node_ != nullptr && __constrain_hash(__node_->__hash_, __bucket_count_) != __bucket_)
            __node_ = nullptr;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_const_local_iterator operator++(int)
    {
        __hash_const_local_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)
    {
        return __x.__node_ == __y.__node_;
    }
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)
        {return !(__x == __y);}

private:
# 659 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_const_local_iterator(__node_pointer __node, size_t __bucket,
                                size_t __bucket_count) throw()
        : __node_(__node),
          __bucket_(__bucket),
          __bucket_count_(__bucket_count)
        {
            if (__node_ != nullptr)
                __node_ = __node_->__next_;
        }

    template <class, class, class, class> friend class __hash_table;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_map_const_iterator;
};

template <class _Alloc>
class __bucket_list_deallocator
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;

    __compressed_pair<size_type, allocator_type> __data_;
public:
    typedef typename __alloc_traits::pointer pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bucket_list_deallocator()
       
        : __data_(0) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bucket_list_deallocator(const allocator_type& __a, size_type __size)
       
        : __data_(__size, __a) {}



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __bucket_list_deallocator(__bucket_list_deallocator&& __x)
       
        : __data_(std::__ndk1::move(__x.__data_))
    {
        __x.size() = 0;
    }



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type& size() throw() {return __data_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __data_.first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type& __alloc() throw() {return __data_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const allocator_type& __alloc() const throw() {return __data_.second();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
    {
        __alloc_traits::deallocate(__alloc(), __p, size());
    }
};

template <class _Alloc> class __hash_map_node_destructor;

template <class _Alloc>
class __hash_node_destructor
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::value_type::value_type value_type;
public:
    typedef typename __alloc_traits::pointer pointer;
private:

    allocator_type& __na_;

    __hash_node_destructor& operator=(const __hash_node_destructor&);

public:
    bool __value_constructed;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __hash_node_destructor(allocator_type& __na,
                                    bool __constructed = false) throw()
        : __na_(__na),
          __value_constructed(__constructed)
        {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, std::__ndk1::addressof(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __hash_map_node_destructor;
};

template <class _Tp, class _Hash, class _Equal, class _Alloc>
class __hash_table
{
public:
    typedef _Tp value_type;
    typedef _Hash hasher;
    typedef _Equal key_equal;
    typedef _Alloc allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
public:
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
public:

    typedef __hash_node<value_type, typename __alloc_traits::void_pointer> __node;
    typedef typename __alloc_traits::template



            rebind_alloc<__node>::other

                                                     __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
    typedef typename __node_traits::pointer __node_pointer;
    typedef typename __node_traits::pointer __node_const_pointer;
    typedef __hash_node_base<__node_pointer> __first_node;
    typedef typename pointer_traits<__node_pointer>::template



            rebind<__first_node>::other

                                                     __node_base_pointer;

private:

    typedef typename __node_traits::template



            rebind_alloc<__node_pointer>::other

                                                            __pointer_allocator;
    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;
    typedef unique_ptr<__node_pointer[], __bucket_list_deleter> __bucket_list;
    typedef allocator_traits<__pointer_allocator> __pointer_alloc_traits;
    typedef typename __bucket_list_deleter::pointer __node_pointer_pointer;


    __bucket_list __bucket_list_;
    __compressed_pair<__first_node, __node_allocator> __p1_;
    __compressed_pair<size_type, hasher> __p2_;
    __compressed_pair<float, key_equal> __p3_;


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type& size() throw() {return __p2_.first();}
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __p2_.first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    hasher& hash_function() throw() {return __p2_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const hasher& hash_function() const throw() {return __p2_.second();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    float& max_load_factor() throw() {return __p3_.first();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    float max_load_factor() const throw() {return __p3_.first();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    key_equal& key_eq() throw() {return __p3_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const key_equal& key_eq() const throw() {return __p3_.second();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __node_allocator& __node_alloc() throw() {return __p1_.second();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const __node_allocator& __node_alloc() const throw()
        {return __p1_.second();}

public:
    typedef __hash_iterator<__node_pointer> iterator;
    typedef __hash_const_iterator<__node_pointer> const_iterator;
    typedef __hash_local_iterator<__node_pointer> local_iterator;
    typedef __hash_const_local_iterator<__node_pointer> const_local_iterator;

    __hash_table()
       




                                                               ;
    __hash_table(const hasher& __hf, const key_equal& __eql);
    __hash_table(const hasher& __hf, const key_equal& __eql,
                 const allocator_type& __a);
    explicit __hash_table(const allocator_type& __a);
    __hash_table(const __hash_table& __u);
    __hash_table(const __hash_table& __u, const allocator_type& __a);

    __hash_table(__hash_table&& __u)
       




                                                            ;
    __hash_table(__hash_table&& __u, const allocator_type& __a);

    ~__hash_table();

    __hash_table& operator=(const __hash_table& __u);

    __hash_table& operator=(__hash_table&& __u)
       



                                                         ;

    template <class _InputIterator>
        void __assign_unique(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw()
    {
        return allocator_traits<__pointer_allocator>::max_size(
            __bucket_list_.get_deleter().__alloc());
    }

    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
    iterator __node_insert_multi(__node_pointer __nd);
    iterator __node_insert_multi(const_iterator __p,
                                             __node_pointer __nd);


    template <class... _Args>
        pair<iterator, bool> __emplace_unique(_Args&&... __args);
    template <class... _Args>
        iterator __emplace_multi(_Args&&... __args);
    template <class... _Args>
        iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);


    pair<iterator, bool> __insert_unique(const value_type& __x);


    template <class _Pp>
        pair<iterator, bool> __insert_unique(_Pp&& __x);



    template <class _Pp>
        iterator __insert_multi(_Pp&& __x);
    template <class _Pp>
        iterator __insert_multi(const_iterator __p, _Pp&& __x);





    void clear() throw();
    void rehash(size_type __n);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void reserve(size_type __n)
        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type bucket_count() const throw()
    {
        return __bucket_list_.get_deleter().size();
    }

    iterator begin() throw();
    iterator end() throw();
    const_iterator begin() const throw();
    const_iterator end() const throw();

    template <class _Key>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        size_type bucket(const _Key& __k) const
        {
            ((void)0)
                                                                                   ;
            return __constrain_hash(hash_function()(__k), bucket_count());
        }

    template <class _Key>
        iterator find(const _Key& __x);
    template <class _Key>
        const_iterator find(const _Key& __x) const;

    typedef __hash_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __first, const_iterator __last);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);
    __node_holder remove(const_iterator __p) throw();

    template <class _Key>
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    void swap(__hash_table& __u)
       





                                                     ;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_bucket_count() const throw()
        {return __pointer_alloc_traits::max_size(__bucket_list_.get_deleter().__alloc());}
    size_type bucket_size(size_type __n) const;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) float load_factor() const throw()
    {
        size_type __bc = bucket_count();
        return __bc != 0 ? (float)size() / __bc : 0.f;
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__)) void max_load_factor(float __mlf) throw()
    {
        ((void)0)
                                                                           ;
        max_load_factor() = std::__ndk1::max(__mlf, load_factor());
    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    local_iterator
    begin(size_type __n)
    {
        ((void)0)
                                                                            ;



        return local_iterator(__bucket_list_[__n], __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    local_iterator
    end(size_type __n)
    {
        ((void)0)
                                                                          ;



        return local_iterator(nullptr, __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator
    cbegin(size_type __n) const
    {
        ((void)0)
                                                                             ;



        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());

    }

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator
    cend(size_type __n) const
    {
        ((void)0)
                                                                           ;



        return const_local_iterator(nullptr, __n, bucket_count());

    }
# 1079 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
private:
    void __rehash(size_type __n);



    template <class ..._Args>
        __node_holder __construct_node(_Args&& ...__args);

    __node_holder __construct_node(value_type&& __v, size_t __hash);



    __node_holder __construct_node(const value_type& __v, size_t __hash);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __copy_assign_alloc(const __hash_table& __u)
        {__copy_assign_alloc(__u, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}
    void __copy_assign_alloc(const __hash_table& __u, true_type);
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        void __copy_assign_alloc(const __hash_table&, false_type) {}

    void __move_assign(__hash_table& __u, false_type);
    void __move_assign(__hash_table& __u, true_type)
       


                                                         ;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__hash_table& __u)
       



        {__move_assign_alloc(__u, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void __move_assign_alloc(__hash_table& __u, true_type)
       


    {
        __bucket_list_.get_deleter().__alloc() =
                std::__ndk1::move(__u.__bucket_list_.get_deleter().__alloc());
        __node_alloc() = std::__ndk1::move(__u.__node_alloc());
    }
    __attribute__ ((__visibility__("hidden"), __always_inline__))
        void __move_assign_alloc(__hash_table&, false_type) throw() {}

    template <class _Ap>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static
    void
    __swap_alloc(_Ap& __x, _Ap& __y)
       


    {
        __swap_alloc(__x, __y,
                     integral_constant<bool,
                        allocator_traits<_Ap>::propagate_on_container_swap::value
                                      >());
    }

    template <class _Ap>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static
    void
    __swap_alloc(_Ap& __x, _Ap& __y, true_type)
       
    {
        using std::__ndk1::swap;
        swap(__x, __y);
    }

    template <class _Ap>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    static
    void
    __swap_alloc(_Ap&, _Ap&, false_type) throw() {}

    void __deallocate(__node_pointer __np) throw();
    __node_pointer __detach() throw();

    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_multimap;
};

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()
   




    : __p2_(0),
      __p3_(1.0f)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,
                                                       const key_equal& __eql)
    : __bucket_list_(nullptr, __bucket_list_deleter()),
      __p1_(),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,
                                                       const key_equal& __eql,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__node_allocator(__a)),
      __p2_(0, __hf),
      __p3_(1.0f, __eql)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__node_allocator(__a)),
      __p2_(0),
      __p3_(1.0f)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)
    : __bucket_list_(nullptr,
          __bucket_list_deleter(allocator_traits<__pointer_allocator>::
              select_on_container_copy_construction(
                  __u.__bucket_list_.get_deleter().__alloc()), 0)),
      __p1_(allocator_traits<__node_allocator>::
          select_on_container_copy_construction(__u.__node_alloc())),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__node_allocator(__a)),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_)
{
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)
       




    : __bucket_list_(std::__ndk1::move(__u.__bucket_list_)),
      __p1_(std::__ndk1::move(__u.__p1_)),
      __p2_(std::__ndk1::move(__u.__p2_)),
      __p3_(std::__ndk1::move(__u.__p3_))
{
    if (size() > 0)
    {
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =
            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));
        __u.__p1_.first().__next_ = nullptr;
        __u.size() = 0;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,
                                                       const allocator_type& __a)
    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__node_allocator(__a)),
      __p2_(0, std::__ndk1::move(__u.hash_function())),
      __p3_(std::__ndk1::move(__u.__p3_))
{
    if (__a == allocator_type(__u.__node_alloc()))
    {
        __bucket_list_.reset(__u.__bucket_list_.release());
        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
        __u.__bucket_list_.get_deleter().size() = 0;
        if (__u.size() > 0)
        {
            __p1_.first().__next_ = __u.__p1_.first().__next_;
            __u.__p1_.first().__next_ = nullptr;
            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =
                static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));
            size() = __u.size();
            __u.size() = 0;
        }
    }
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()
{
    __deallocate(__p1_.first().__next_);



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(
        const __hash_table& __u, true_type)
{
    if (__node_alloc() != __u.__node_alloc())
    {
        clear();
        __bucket_list_.reset();
        __bucket_list_.get_deleter().size() = 0;
    }
    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();
    __node_alloc() = __u.__node_alloc();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)
{
    if (this != &__u)
    {
        __copy_assign_alloc(__u);
        hash_function() = __u.hash_function();
        key_eq() = __u.key_eq();
        max_load_factor() = __u.max_load_factor();
        __assign_multi(__u.begin(), __u.end());
    }
    return *this;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate(__node_pointer __np)
    throw()
{
    __node_allocator& __na = __node_alloc();
    while (__np != nullptr)
    {
        __node_pointer __next = __np->__next_;
# 1347 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
        __node_traits::destroy(__na, std::__ndk1::addressof(__np->__value_));
        __node_traits::deallocate(__na, __np, 1);
        __np = __next;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() throw()
{
    size_type __bc = bucket_count();
    for (size_type __i = 0; __i < __bc; ++__i)
        __bucket_list_[__i] = nullptr;
    size() = 0;
    __node_pointer __cache = __p1_.first().__next_;
    __p1_.first().__next_ = nullptr;
    return __cache;
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
        __hash_table& __u, true_type)
   



{
    clear();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
    __u.__bucket_list_.get_deleter().size() = 0;
    __move_assign_alloc(__u);
    size() = __u.size();
    hash_function() = std::__ndk1::move(__u.hash_function());
    max_load_factor() = __u.max_load_factor();
    key_eq() = std::__ndk1::move(__u.key_eq());
    __p1_.first().__next_ = __u.__p1_.first().__next_;
    if (size() > 0)
    {
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =
            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));
        __u.__p1_.first().__next_ = nullptr;
        __u.size() = 0;
    }



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(
        __hash_table& __u, false_type)
{
    if (__node_alloc() == __u.__node_alloc())
        __move_assign(__u, true_type());
    else
    {
        hash_function() = std::__ndk1::move(__u.hash_function());
        key_eq() = std::__ndk1::move(__u.key_eq());
        max_load_factor() = __u.max_load_factor();
        if (bucket_count() != 0)
        {
            __node_pointer __cache = __detach();




                const_iterator __i = __u.begin();
                while (__cache != nullptr && __u.size() != 0)
                {
                    __cache->__value_ = std::__ndk1::move(__u.remove(__i++)->__value_);
                    __node_pointer __next = __cache->__next_;
                    __node_insert_multi(__cache);
                    __cache = __next;
                }
# 1434 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
            __deallocate(__cache);
        }
        const_iterator __i = __u.begin();
        while (__u.size() != 0)
        {
            __node_holder __h =
                    __construct_node(std::__ndk1::move(__u.remove(__i++)->__value_));
            __node_insert_multi(__h.get());
            __h.release();
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)
   




{
    __move_assign(__u, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,
                                                          _InputIterator __last)
{
    if (bucket_count() != 0)
    {
        __node_pointer __cache = __detach();




            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__value_ = *__first;
                __node_pointer __next = __cache->__next_;
                __node_insert_unique(__cache);
                __cache = __next;
            }
# 1492 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
        __deallocate(__cache);
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,
                                                         _InputIterator __last)
{
    if (bucket_count() != 0)
    {
        __node_pointer __cache = __detach();




            for (; __cache != nullptr && __first != __last; ++__first)
            {
                __cache->__value_ = *__first;
                __node_pointer __next = __cache->__next_;
                __node_insert_multi(__cache);
                __cache = __next;
            }
# 1526 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
        __deallocate(__cache);
    }
    for (; __first != __last; ++__first)
        __insert_multi(*__first);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() throw()
{



    return iterator(__p1_.first().__next_);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() throw()
{



    return iterator(nullptr);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const throw()
{



    return const_iterator(__p1_.first().__next_);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const throw()
{



    return const_iterator(nullptr);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() throw()
{
    if (size() > 0)
    {
        __deallocate(__p1_.first().__next_);
        __p1_.first().__next_ = nullptr;
        size_type __bc = bucket_count();
        for (size_type __i = 0; __i < __bc; ++__i)
            __bucket_list_[__i] = nullptr;
        size() = 0;
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)
{
    __nd->__hash_ = hash_function()(__nd->__value_);
    size_type __bc = bucket_count();
    bool __inserted = false;
    __node_pointer __ndptr;
    size_t __chash;
    if (__bc != 0)
    {
        __chash = __constrain_hash(__nd->__hash_, __bc);
        __ndptr = __bucket_list_[__chash];
        if (__ndptr != nullptr)
        {
            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&
                                             __constrain_hash(__ndptr->__hash_, __bc) == __chash;
                                                     __ndptr = __ndptr->__next_)
            {
                if (key_eq()(__ndptr->__value_, __nd->__value_))
                    goto __done;
            }
        }
    }
    {
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__ndk1::max<size_type>(2 * __bc + !__is_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
            __chash = __constrain_hash(__nd->__hash_, __bc);
        }

        __node_pointer __pn = __bucket_list_[__chash];
        if (__pn == nullptr)
        {
            __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));
            __nd->__next_ = __pn->__next_;
            __pn->__next_ = __nd;

            __bucket_list_[__chash] = __pn;
            if (__nd->__next_ != nullptr)
                __bucket_list_[__constrain_hash(__nd->__next_->__hash_, __bc)] = __nd;
        }
        else
        {
            __nd->__next_ = __pn->__next_;
            __pn->__next_ = __nd;
        }
        __ndptr = __nd;

        ++size();
        __inserted = true;
    }
__done:



    return pair<iterator, bool>(iterator(__ndptr), __inserted);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)
{
    __cp->__hash_ = hash_function()(__cp->__value_);
    size_type __bc = bucket_count();
    if (size()+1 > __bc * max_load_factor() || __bc == 0)
    {
        rehash(std::__ndk1::max<size_type>(2 * __bc + !__is_power2(__bc),
                       size_type(ceil(float(size() + 1) / max_load_factor()))));
        __bc = bucket_count();
    }
    size_t __chash = __constrain_hash(__cp->__hash_, __bc);
    __node_pointer __pn = __bucket_list_[__chash];
    if (__pn == nullptr)
    {
        __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));
        __cp->__next_ = __pn->__next_;
        __pn->__next_ = __cp;

        __bucket_list_[__chash] = __pn;
        if (__cp->__next_ != nullptr)
            __bucket_list_[__constrain_hash(__cp->__next_->__hash_, __bc)] = __cp;
    }
    else
    {
        for (bool __found = false; __pn->__next_ != nullptr &&
                                   __constrain_hash(__pn->__next_->__hash_, __bc) == __chash;
                                                           __pn = __pn->__next_)
        {





            if (__found != (__pn->__next_->__hash_ == __cp->__hash_ &&
                            key_eq()(__pn->__next_->__value_, __cp->__value_)))
            {
                if (!__found)
                    __found = true;
                else
                    break;
            }
        }
        __cp->__next_ = __pn->__next_;
        __pn->__next_ = __cp;
        if (__cp->__next_ != nullptr)
        {
            size_t __nhash = __constrain_hash(__cp->__next_->__hash_, __bc);
            if (__nhash != __chash)
                __bucket_list_[__nhash] = __cp;
        }
    }
    ++size();



    return iterator(__cp);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(
        const_iterator __p, __node_pointer __cp)
{





    if (__p != end() && key_eq()(*__p, __cp->__value_))
    {
        __node_pointer __np = __p.__node_;
        __cp->__hash_ = __np->__hash_;
        size_type __bc = bucket_count();
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__ndk1::max<size_type>(2 * __bc + !__is_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
        }
        size_t __chash = __constrain_hash(__cp->__hash_, __bc);
        __node_pointer __pp = __bucket_list_[__chash];
        while (__pp->__next_ != __np)
            __pp = __pp->__next_;
        __cp->__next_ = __np;
        __pp->__next_ = __cp;
        ++size();



        return iterator(__cp);

    }
    return __node_insert_multi(__cp);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_unique(const value_type& __x)
{
    size_t __hash = hash_function()(__x);
    size_type __bc = bucket_count();
    bool __inserted = false;
    __node_pointer __nd;
    size_t __chash;
    if (__bc != 0)
    {
        __chash = __constrain_hash(__hash, __bc);
        __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                                       __constrain_hash(__nd->__hash_, __bc) == __chash;
                                                           __nd = __nd->__next_)
            {
                if (key_eq()(__nd->__value_, __x))
                    goto __done;
            }
        }
    }
    {
        __node_holder __h = __construct_node(__x, __hash);
        if (size()+1 > __bc * max_load_factor() || __bc == 0)
        {
            rehash(std::__ndk1::max<size_type>(2 * __bc + !__is_power2(__bc),
                           size_type(ceil(float(size() + 1) / max_load_factor()))));
            __bc = bucket_count();
            __chash = __constrain_hash(__hash, __bc);
        }

        __node_pointer __pn = __bucket_list_[__chash];
        if (__pn == nullptr)
        {
            __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));
            __h->__next_ = __pn->__next_;
            __pn->__next_ = __h.get();

            __bucket_list_[__chash] = __pn;
            if (__h->__next_ != nullptr)
                __bucket_list_[__constrain_hash(__h->__next_->__hash_, __bc)] = __h.get();
        }
        else
        {
            __h->__next_ = __pn->__next_;
            __pn->__next_ = __h.get();
        }
        __nd = __h.release();

        ++size();
        __inserted = true;
    }
__done:



    return pair<iterator, bool>(iterator(__nd), __inserted);

}




template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__ndk1::forward<_Args>(__args)...);
    pair<iterator, bool> __r = __node_insert_unique(__h.get());
    if (__r.second)
        __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__ndk1::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__h.get());
    __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(
        const_iterator __p, _Args&&... __args)
{





    __node_holder __h = __construct_node(std::__ndk1::forward<_Args>(__args)...);
    iterator __r = __node_insert_multi(__p, __h.get());
    __h.release();
    return __r;
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Pp>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_unique(_Pp&& __x)
{
    __node_holder __h = __construct_node(std::__ndk1::forward<_Pp>(__x));
    pair<iterator, bool> __r = __node_insert_unique(__h.get());
    if (__r.second)
        __h.release();
    return __r;
}





template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Pp>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(_Pp&& __x)
{
    __node_holder __h = __construct_node(std::__ndk1::forward<_Pp>(__x));
    iterator __r = __node_insert_multi(__h.get());
    __h.release();
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Pp>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,
                                                         _Pp&& __x)
{





    __node_holder __h = __construct_node(std::__ndk1::forward<_Pp>(__x));
    iterator __r = __node_insert_multi(__p, __h.get());
    __h.release();
    return __r;
}
# 1937 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)
{
    if (__n == 1)
        __n = 2;
    else if (__n & (__n - 1))
        __n = __next_prime(__n);
    size_type __bc = bucket_count();
    if (__n > __bc)
        __rehash(__n);
    else if (__n < __bc)
    {
        __n = std::__ndk1::max<size_type>
              (
                  __n,
                  __is_power2(__bc) ? __next_pow2(size_t(ceil(float(size()) / max_load_factor()))) :
                                      __next_prime(size_t(ceil(float(size()) / max_load_factor())))
              );
        if (__n < __bc)
            __rehash(__n);
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)
{



    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();
    __bucket_list_.reset(__nbc > 0 ?
                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);
    __bucket_list_.get_deleter().size() = __nbc;
    if (__nbc > 0)
    {
        for (size_type __i = 0; __i < __nbc; ++__i)
            __bucket_list_[__i] = nullptr;
        __node_pointer __pp(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first())));
        __node_pointer __cp = __pp->__next_;
        if (__cp != nullptr)
        {
            size_type __chash = __constrain_hash(__cp->__hash_, __nbc);
            __bucket_list_[__chash] = __pp;
            size_type __phash = __chash;
            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;
                                                           __cp = __pp->__next_)
            {
                __chash = __constrain_hash(__cp->__hash_, __nbc);
                if (__chash == __phash)
                    __pp = __cp;
                else
                {
                    if (__bucket_list_[__chash] == nullptr)
                    {
                        __bucket_list_[__chash] = __pp;
                        __pp = __cp;
                        __phash = __chash;
                    }
                    else
                    {
                        __node_pointer __np = __cp;
                        for (; __np->__next_ != nullptr &&
                               key_eq()(__cp->__value_, __np->__next_->__value_);
                                                           __np = __np->__next_)
                            ;
                        __pp->__next_ = __np->__next_;
                        __np->__next_ = __bucket_list_[__chash]->__next_;
                        __bucket_list_[__chash]->__next_ = __cp;

                    }
                }
            }
        }
    }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __node_pointer __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                                       __constrain_hash(__nd->__hash_, __bc) == __chash;
                                                           __nd = __nd->__next_)
            {
                if (key_eq()(__nd->__value_, __k))



                    return iterator(__nd);

            }
        }
    }
    return end();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const
{
    size_t __hash = hash_function()(__k);
    size_type __bc = bucket_count();
    if (__bc != 0)
    {
        size_t __chash = __constrain_hash(__hash, __bc);
        __node_const_pointer __nd = __bucket_list_[__chash];
        if (__nd != nullptr)
        {
            for (__nd = __nd->__next_; __nd != nullptr &&
                                           __constrain_hash(__nd->__hash_, __bc) == __chash;
                                                           __nd = __nd->__next_)
            {
                if (key_eq()(__nd->__value_, __k))



                    return const_iterator(__nd);

            }
        }

    }
    return end();
}




template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class ..._Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)
{
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_), std::__ndk1::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = hash_function()(__h->__value_);
    __h->__next_ = nullptr;
    return __h;
}



template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(value_type&& __v,
                                                           size_t __hash)
{
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_), std::__ndk1::move(__v));
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = __hash;
    __h->__next_ = nullptr;
    return __h;
}
# 2124 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(const value_type& __v,
                                                           size_t __hash)
{
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_), __v);
    __h.get_deleter().__value_constructed = true;
    __h->__hash_ = __hash;
    __h->__next_ = nullptr;
    return std::__ndk1::move(__h);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)
{
    __node_pointer __np = __p.__node_;
# 2151 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    iterator __r(__np);

    ++__r;
    remove(__p);
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,
                                                const_iterator __last)
{
# 2171 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    for (const_iterator __p = __first; __first != __last; __p = __first)
    {
        ++__first;
        erase(__p);
    }
    __node_pointer __np = __last.__node_;



    return iterator (__np);

}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)
{
    size_type __r = 0;
    iterator __i = find(__k);
    if (__i != end())
    {
        iterator __e = end();
        do
        {
            erase(__i++);
            ++__r;
        } while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) throw()
{

    __node_pointer __cn = __p.__node_;
    size_type __bc = bucket_count();
    size_t __chash = __constrain_hash(__cn->__hash_, __bc);

    __node_pointer __pn = __bucket_list_[__chash];
    for (; __pn->__next_ != __cn; __pn = __pn->__next_)
        ;



    if (__pn == static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()))
                            || __constrain_hash(__pn->__hash_, __bc) != __chash)
    {
        if (__cn->__next_ == nullptr || __constrain_hash(__cn->__next_->__hash_, __bc) != __chash)
            __bucket_list_[__chash] = nullptr;
    }

    if (__cn->__next_ != nullptr)
    {
        size_t __nhash = __constrain_hash(__cn->__next_->__hash_, __bc);
        if (__nhash != __chash)
            __bucket_list_[__nhash] = __pn;
    }

    __pn->__next_ = __cn->__next_;
    __cn->__next_ = nullptr;
    --size();
# 2262 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
    return __node_holder(__cn, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const
{
    return static_cast<size_type>(find(__k) != end());
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const
{
    size_type __r = 0;
    const_iterator __i = find(__k);
    if (__i != end())
    {
        const_iterator __e = end();
        do
        {
            ++__i;
            ++__r;
        } while (__i != __e && key_eq()(*__i, __k));
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
        const _Key& __k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
        ++__j;
    return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(
        const _Key& __k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
        ++__j;
    return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
        const _Key& __k)
{
    iterator __i = find(__k);
    iterator __j = __i;
    if (__i != end())
    {
        iterator __e = end();
        do
        {
            ++__j;
        } while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(
        const _Key& __k) const
{
    const_iterator __i = find(__k);
    const_iterator __j = __i;
    if (__i != end())
    {
        const_iterator __e = end();
        do
        {
            ++__j;
        } while (__j != __e && key_eq()(*__j, __k));
    }
    return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)
   






{
    {
    __node_pointer_pointer __npp = __bucket_list_.release();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __u.__bucket_list_.reset(__npp);
    }
    std::__ndk1::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());
    __swap_alloc(__bucket_list_.get_deleter().__alloc(),
             __u.__bucket_list_.get_deleter().__alloc());
    __swap_alloc(__node_alloc(), __u.__node_alloc());
    std::__ndk1::swap(__p1_.first().__next_, __u.__p1_.first().__next_);
    __p2_.swap(__u.__p2_);
    __p3_.swap(__u.__p3_);
    if (size() > 0)
        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =
            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));
    if (__u.size() > 0)
        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash_, __u.bucket_count())] =
            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__u.__p1_.first()));



}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const
{
    ((void)0)
                                                                              ;
    __node_const_pointer __np = __bucket_list_[__n];
    size_type __bc = bucket_count();
    size_type __r = 0;
    if (__np != nullptr)
    {
        for (__np = __np->__next_; __np != nullptr &&
                                   __constrain_hash(__np->__hash_, __bc) == __n;
                                                    __np = __np->__next_, ++__r)
            ;
    }
    return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,
     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)
   
{
    __x.swap(__y);
}
# 2455 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/__hash_table" 3
} }
# 351 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/functional" 1 3
# 483 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/functional" 3
       
# 484 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/functional" 3


namespace std { namespace __ndk1 {


template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) plus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) + std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) minus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) - std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) multiplies<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) * std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) divides<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) / std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) modulus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) % std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) negate : unary_function<_Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};


template <>
struct __attribute__ ((__visibility__("default"))) negate<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Tp&& __x) const
        { return -std::__ndk1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) == std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) not_equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) != std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) greater : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) greater<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) > std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};






template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) greater_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) >= std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) less_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) <= std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) logical_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) && std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) logical_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) || std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) logical_not : unary_function<_Tp, bool>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};


template <>
struct __attribute__ ((__visibility__("default"))) logical_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Tp&& __x) const
        { return !std::__ndk1::forward<_Tp>(__x); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) bit_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) & std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) bit_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) | std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>



struct __attribute__ ((__visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};


template <>
struct __attribute__ ((__visibility__("default"))) bit_xor<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_T1&& __t, _T2&& __u) const
        { return std::__ndk1::forward<_T1>(__t) ^ std::__ndk1::forward<_T2>(__u); }
    typedef void is_transparent;
};




template <class _Tp = void>
struct __attribute__ ((__visibility__("default"))) bit_not : unary_function<_Tp, _Tp>
{
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};

template <>
struct __attribute__ ((__visibility__("default"))) bit_not<void>
{
    template <class _Tp>
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    auto operator()(_Tp&& __x) const
        { return ~std::__ndk1::forward<_Tp>(__x); }
    typedef void is_transparent;
};


template <class _Predicate>
class __attribute__ ((__visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
{
    _Predicate __pred_;
public:
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit unary_negate(const _Predicate& __pred)
        : __pred_(__pred) {}
    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::argument_type& __x) const
        {return !__pred_(__x);}
};

template <class _Predicate>
inline constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
unary_negate<_Predicate>
not1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}

template <class _Predicate>
class __attribute__ ((__visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool>
{
    _Predicate __pred_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit constexpr
    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}

    constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const typename _Predicate::first_argument_type& __x,
                    const typename _Predicate::second_argument_type& __y) const
        {return !__pred_(__x, __y);}
};

template <class _Predicate>
inline constexpr __attribute__ ((__visibility__("hidden"), __always_inline__))
binary_negate<_Predicate>
not2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}

template <class __Operation>
class __attribute__ ((__visibility__("default"))) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::first_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) binder1st(const __Operation& __x,
                               const typename __Operation::first_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::second_argument_type& __x) const
            {return op(value, __x);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder1st<__Operation>
bind1st(const __Operation& __op, const _Tp& __x)
    {return binder1st<__Operation>(__op, __x);}

template <class __Operation>
class __attribute__ ((__visibility__("default"))) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type>
{
protected:
    __Operation op;
    typename __Operation::second_argument_type value;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)
        : op(__x), value(__y) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        ( typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type operator()
        (const typename __Operation::first_argument_type& __x) const
            {return op(__x, value);}
};

template <class __Operation, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
binder2nd<__Operation>
bind2nd(const __Operation& __op, const _Tp& __x)
    {return binder2nd<__Operation>(__op, __x);}

template <class _Arg, class _Result>
class __attribute__ ((__visibility__("default"))) pointer_to_unary_function
    : public unary_function<_Arg, _Result>
{
    _Result (*__f_)(_Arg);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_unary_function(_Result (*__f)(_Arg))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg __x) const
        {return __f_(__x);}
};

template <class _Arg, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_unary_function<_Arg,_Result>
ptr_fun(_Result (*__f)(_Arg))
    {return pointer_to_unary_function<_Arg,_Result>(__f);}

template <class _Arg1, class _Arg2, class _Result>
class __attribute__ ((__visibility__("default"))) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
{
    _Result (*__f_)(_Arg1, _Arg2);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))
        : __f_(__f) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const
        {return __f_(__x, __y);}
};

template <class _Arg1, class _Arg2, class _Result>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1,_Arg2))
    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__visibility__("default"))) mem_fun_t : public unary_function<_Tp*, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p) const
        {return (__p->*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__visibility__("default"))) mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)())
    {return mem_fun_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template<class _Sp, class _Tp>
class __attribute__ ((__visibility__("default"))) mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)();
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p) const
        {return (__p.*__p_)();}
};

template<class _Sp, class _Tp, class _Ap>
class __attribute__ ((__visibility__("default"))) mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template<class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)())
    {return mem_fun_ref_t<_Sp,_Tp>(__f);}

template<class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap))
    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__visibility__("default"))) const_mem_fun_t : public unary_function<const _Tp*, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p) const
        {return (__p->*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__visibility__("default"))) const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp* __p, _Ap __x) const
        {return (__p->*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_t<_Sp,_Tp>
mem_fun(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_t<_Sp,_Tp,_Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}

template <class _Sp, class _Tp>
class __attribute__ ((__visibility__("default"))) const_mem_fun_ref_t : public unary_function<_Tp, _Sp>
{
    _Sp (_Tp::*__p_)() const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p) const
        {return (__p.*__p_)();}
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__ ((__visibility__("default"))) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp>
{
    _Sp (_Tp::*__p_)(_Ap) const;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)
        : __p_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp& __p, _Ap __x) const
        {return (__p.*__p_)(__x);}
};

template <class _Sp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun_ref_t<_Sp,_Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const)
    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const_mem_fun1_ref_t<_Sp,_Tp,_Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)
    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}







template <class _Tp>
class __mem_fn
    : public __weak_result_type<_Tp>
{
public:

    typedef _Tp type;
private:
    type __f_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __mem_fn(type __f) : __f_(__f) {}


    template <class... _ArgTypes>
       __attribute__ ((__visibility__("hidden"), __always_inline__))
       typename __invoke_return<type, _ArgTypes...>::type
          operator() (_ArgTypes&&... __args) const
          {
              return __invoke(__f_, std::__ndk1::forward<_ArgTypes>(__args)...);
          }
};

template<class _Rp, class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::* __pm)
{
    return __mem_fn<_Rp _Tp::*>(__pm);
}



class __attribute__ ((__visibility__("default"))) bad_function_call
    : public exception
{
};

template<class _Fp> class __attribute__ ((__visibility__("default"))) function;

namespace __function
{

template<class _Rp, class ..._ArgTypes>
struct __maybe_derive_from_unary_function
{
};

template<class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp>
{
};

template<class _Rp, class ..._ArgTypes>
struct __maybe_derive_from_binary_function
{
};

template<class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp>
{
};

template<class _Fp> class __base;

template<class _Rp, class ..._ArgTypes>
class __base<_Rp(_ArgTypes...)>
{
    __base(const __base&);
    __base& operator=(const __base&);
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) __base() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) virtual ~__base() {}
    virtual __base* __clone() const = 0;
    virtual void __clone(__base*) const = 0;
    virtual void destroy() throw() = 0;
    virtual void destroy_deallocate() throw() = 0;
    virtual _Rp operator()(_ArgTypes&& ...) = 0;




};

template<class _FD, class _Alloc, class _FB> class __func;

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)>
{
    __compressed_pair<_Fp, _Alloc> __f_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __func(_Fp&& __f)
        : __f_(piecewise_construct, std::__ndk1::forward_as_tuple(std::__ndk1::move(__f)),
                                    std::__ndk1::forward_as_tuple()) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __func(const _Fp& __f, const _Alloc& __a)
        : __f_(piecewise_construct, std::__ndk1::forward_as_tuple(__f),
                                    std::__ndk1::forward_as_tuple(__a)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __func(const _Fp& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__ndk1::forward_as_tuple(__f),
                                    std::__ndk1::forward_as_tuple(std::__ndk1::move(__a))) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __func(_Fp&& __f, _Alloc&& __a)
        : __f_(piecewise_construct, std::__ndk1::forward_as_tuple(std::__ndk1::move(__f)),
                                    std::__ndk1::forward_as_tuple(std::__ndk1::move(__a))) {}
    virtual __base<_Rp(_ArgTypes...)>* __clone() const;
    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;
    virtual void destroy() throw();
    virtual void destroy_deallocate() throw();
    virtual _Rp operator()(_ArgTypes&& ... __arg);




};

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
__base<_Rp(_ArgTypes...)>*
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    typedef __allocator_destructor<_Ap> _Dp;
    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
    return __hold.release();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const
{
    ::new (__p) __func(__f_.first(), __f_.second());
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() throw()
{
    __f_.~__compressed_pair<_Fp, _Alloc>();
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
void
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() throw()
{
    typedef typename _Alloc::template rebind<__func>::other _Ap;
    _Ap __a(__f_.second());
    __f_.~__compressed_pair<_Fp, _Alloc>();
    __a.deallocate(this, 1);
}

template<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>
_Rp
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)
{
    return __invoke(__f_.first(), std::__ndk1::forward<_ArgTypes>(__arg)...);
}
# 1393 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/functional" 3
}

template<class _Rp, class ..._ArgTypes>
class __attribute__ ((__visibility__("default"))) function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>
{
    typedef __function::__base<_Rp(_ArgTypes...)> __base;
    typename aligned_storage<3*sizeof(void*)>::type __buf_;
    __base* __f_;

    template <class _Fp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const _Fp&) {return true;}
    template <class _R2, class ..._Ap>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (*__p)(_Ap...)) {return __p;}
    template <class _R2, class _Cp, class ..._Ap>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_Ap...)) {return __p;}
    template <class _R2, class _Cp, class ..._Ap>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const) {return __p;}
    template <class _R2, class _Cp, class ..._Ap>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) volatile) {return __p;}
    template <class _R2, class _Cp, class ..._Ap>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const volatile) {return __p;}
    template <class _R2, class ..._Ap>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        static bool __not_null(const function<_Rp(_Ap...)>& __p) {return __p;}

    template <class _Fp, bool = !is_same<_Fp, function>::value &&
                                __invokable<_Fp&, _ArgTypes...>::value>
        struct __callable;
    template <class _Fp>
        struct __callable<_Fp, true>
        {
            static const bool value =
                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,
                               _Rp>::value;
        };
    template <class _Fp>
        struct __callable<_Fp, false>
        {
            static const bool value = false;
        };
public:
    typedef _Rp result_type;


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    function() throw() : __f_(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    function(nullptr_t) throw() : __f_(0) {}
    function(const function&);
    function(function&&) throw();
    template<class _Fp>
      function(_Fp, typename enable_if
                                     <
                                        __callable<_Fp>::value &&
                                        !is_same<_Fp, function>::value
                                      >::type* = 0);

    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&) throw() : __f_(0) {}
    template<class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      function(allocator_arg_t, const _Alloc&, nullptr_t) throw() : __f_(0) {}
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, const function&);
    template<class _Alloc>
      function(allocator_arg_t, const _Alloc&, function&&);
    template<class _Fp, class _Alloc>
      function(allocator_arg_t, const _Alloc& __a, _Fp __f,
               typename enable_if<__callable<_Fp>::value>::type* = 0);

    function& operator=(const function&);
    function& operator=(function&&) throw();
    function& operator=(nullptr_t) throw();
    template<class _Fp>
      typename enable_if
      <
        __callable<typename decay<_Fp>::type>::value &&
        !is_same<typename remove_reference<_Fp>::type, function>::value,
        function&
      >::type
      operator=(_Fp&&);

    ~function();


    void swap(function&) throw();
    template<class _Fp, class _Alloc>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      void assign(_Fp&& __f, const _Alloc& __a)
        {function(allocator_arg, __a, std::__ndk1::forward<_Fp>(__f)).swap(*this);}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
        explicit operator bool() const throw() {return __f_;}


    template<class _R2, class... _ArgTypes2>
      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;
    template<class _R2, class... _ArgTypes2>
      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;
public:

    _Rp operator()(_ArgTypes...) const;







};

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                     const function& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (const __base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
        __f_ = __f.__f_->__clone();
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::function(function&& __f) throw()
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}

template<class _Rp, class ..._ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,
                                     function&& __f)
{
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp>
function<_Rp(_ArgTypes...)>::function(_Fp __f,
                                     typename enable_if
                                     <
                                        __callable<_Fp>::value &&
                                        !is_same<_Fp, function>::value
                                     >::type*)
    : __f_(0)
{
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;
        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(std::__ndk1::move(__f));
        }
        else
        {
            typedef allocator<_FF> _Ap;
            _Ap __a;
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(std::__ndk1::move(__f), allocator<_Fp>(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp, class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,
                                     typename enable_if<__callable<_Fp>::value>::type*)
    : __f_(0)
{
    typedef allocator_traits<_Alloc> __alloc_traits;
    if (__not_null(__f))
    {
        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;
        typedef typename __alloc_traits::template



            rebind_alloc<_FF>::other

            _Ap;
        _Ap __a(__a0);
        if (sizeof(_FF) <= sizeof(__buf_) &&
            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)
        {
            __f_ = (__base*)&__buf_;
            ::new (__f_) _FF(std::__ndk1::move(__f), _Alloc(__a));
        }
        else
        {
            typedef __allocator_destructor<_Ap> _Dp;
            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
            ::new (__hold.get()) _FF(std::__ndk1::move(__f), _Alloc(__a));
            __f_ = __hold.release();
        }
    }
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(const function& __f)
{
    function(__f).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(function&& __f) throw()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
    if (__f.__f_ == 0)
        __f_ = 0;
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f_ = (__base*)&__buf_;
        __f.__f_->__clone(__f_);
    }
    else
    {
        __f_ = __f.__f_;
        __f.__f_ = 0;
    }
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>&
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) throw()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
    __f_ = 0;
    return *this;
}

template<class _Rp, class ..._ArgTypes>
template <class _Fp>
typename enable_if
<
    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&
    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,
    function<_Rp(_ArgTypes...)>&
>::type
function<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)
{
    function(std::__ndk1::forward<_Fp>(__f)).swap(*this);
    return *this;
}

template<class _Rp, class ..._ArgTypes>
function<_Rp(_ArgTypes...)>::~function()
{
    if (__f_ == (__base*)&__buf_)
        __f_->destroy();
    else if (__f_)
        __f_->destroy_deallocate();
}

template<class _Rp, class ..._ArgTypes>
void
function<_Rp(_ArgTypes...)>::swap(function& __f) throw()
{
    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)
    {
        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
        __base* __t = (__base*)&__tempbuf;
        __f_->__clone(__t);
        __f_->destroy();
        __f_ = 0;
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = 0;
        __f_ = (__base*)&__buf_;
        __t->__clone((__base*)&__f.__buf_);
        __t->destroy();
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f_ == (__base*)&__buf_)
    {
        __f_->__clone((__base*)&__f.__buf_);
        __f_->destroy();
        __f_ = __f.__f_;
        __f.__f_ = (__base*)&__f.__buf_;
    }
    else if (__f.__f_ == (__base*)&__f.__buf_)
    {
        __f.__f_->__clone((__base*)&__buf_);
        __f.__f_->destroy();
        __f.__f_ = __f_;
        __f_ = (__base*)&__buf_;
    }
    else
        std::__ndk1::swap(__f_, __f.__f_);
}

template<class _Rp, class ..._ArgTypes>
_Rp
function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const
{




    return (*__f_)(std::__ndk1::forward<_ArgTypes>(__arg)...);
}
# 1792 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/functional" 3
template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) throw() {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) throw() {return !__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) throw() {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) throw() {return (bool)__f;}

template <class _Rp, class... _ArgTypes>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) throw()
{return __x.swap(__y);}

template<class _Tp> struct __is_bind_expression : public false_type {};
template<class _Tp> struct __attribute__ ((__visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};
template<class _Tp> struct __attribute__ ((__visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

namespace placeholders
{

template <int _Np> struct __ph {};

__attribute__ ((__visibility__("default"))) extern __ph<1> _1;
__attribute__ ((__visibility__("default"))) extern __ph<2> _2;
__attribute__ ((__visibility__("default"))) extern __ph<3> _3;
__attribute__ ((__visibility__("default"))) extern __ph<4> _4;
__attribute__ ((__visibility__("default"))) extern __ph<5> _5;
__attribute__ ((__visibility__("default"))) extern __ph<6> _6;
__attribute__ ((__visibility__("default"))) extern __ph<7> _7;
__attribute__ ((__visibility__("default"))) extern __ph<8> _8;
__attribute__ ((__visibility__("default"))) extern __ph<9> _9;
__attribute__ ((__visibility__("default"))) extern __ph<10> _10;

}

template<int _Np>
struct __is_placeholder<placeholders::__ph<_Np> >
    : public integral_constant<int, _Np> {};

template <class _Tp, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
__mu(reference_wrapper<_Tp> __t, _Uj&)
{
    return __t.get();
}

template <class _Ti, class ..._Uj, size_t ..._Indx>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __invoke_of<_Ti&, _Uj...>::type
__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)
{
    return __ti(std::__ndk1::forward<_Uj>(get<_Indx>(__uj))...);
}

template <class _Ti, class ..._Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_bind_expression<_Ti>::value,
    typename __invoke_of<_Ti&, _Uj...>::type
>::type
__mu(_Ti& __ti, tuple<_Uj...>& __uj)
{
    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
    return __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj>
struct __mu_return2 {};

template <class _Ti, class _Uj>
struct __mu_return2<true, _Ti, _Uj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type
>::type
__mu(_Ti&, _Uj& __uj)
{
    const size_t _Indx = is_placeholder<_Ti>::value - 1;
    return std::__ndk1::forward<typename tuple_element<_Indx, _Uj>::type>(get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    !is_bind_expression<_Ti>::value &&
    is_placeholder<_Ti>::value == 0 &&
    !__is_reference_wrapper<_Ti>::value,
    _Ti&
>::type
__mu(_Ti& __ti, _Uj&)
{
    return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct ____mu_return;

template <bool _Invokable, class _Ti, class ..._Uj>
struct ____mu_return_invokable
{
    typedef __nat type;
};

template <class _Ti, class ..._Uj>
struct ____mu_return_invokable<true, _Ti, _Uj...>
{
    typedef typename __invoke_of<_Ti&, _Uj...>::type type;
};

template <class _Ti, class ..._Uj>
struct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >
    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>
{
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, true, _TupleUj>
{
    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,
                                   _TupleUj>::type&& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, true, false, false, _TupleUj>
{
    typedef typename _Ti::type& type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, false, _TupleUj>
{
    typedef _Ti& type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public ____mu_return<_Ti,
                           __is_reference_wrapper<_Ti>::value,
                           is_bind_expression<_Ti>::value,
                           0 < is_placeholder<_Ti>::value &&
                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,
                           _TupleUj>
{
};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct _is_valid_bind_return
{
    static const bool value = false;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct _is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct _is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>
{
    static const bool value = __invokable<_Fp,
                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = _is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class ..._BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>
{
    typedef typename __invoke_of
    <
        _Fp&,
        typename __mu_return
        <
            const _BoundArgs,
            _TupleUj
        >::type...
    >::type type;
};

template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,
                _Args&& __args)
{
    return __invoke(__f, __mu(get<_Indx>(__bound_args), __args)...);
}

template<class _Fp, class ..._BoundArgs>
class __bind
    : public __weak_result_type<typename decay<_Fp>::type>
{
protected:
    typedef typename decay<_Fp>::type _Fd;
    typedef tuple<typename decay<_BoundArgs>::type...> _Td;
private:
    _Fd __f_;
    _Td __bound_args_;

    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
public:
# 2069 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/functional" 3
    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)
        : __f_(std::__ndk1::forward<_Gp>(__f)),
          __bound_args_(std::__ndk1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args)
        {
            return __apply_functor(__f_, __bound_args_, __indices(),
                                  tuple<_Args&&...>(std::__ndk1::forward<_Args>(__args)...));
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type
        operator()(_Args&& ...__args) const
        {
            return __apply_functor(__f_, __bound_args_, __indices(),
                                   tuple<_Args&&...>(std::__ndk1::forward<_Args>(__args)...));
        }
};

template<class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};

template<class _Rp, class _Fp, class ..._BoundArgs>
class __bind_r
    : public __bind<_Fp, _BoundArgs...>
{
    typedef __bind<_Fp, _BoundArgs...> base;
    typedef typename base::_Fd _Fd;
    typedef typename base::_Td _Td;
public:
    typedef _Rp result_type;
# 2139 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/functional" 3
    template <class _Gp, class ..._BA,
              class = typename enable_if
                               <
                                  is_constructible<_Fd, _Gp>::value &&
                                  !is_same<typename remove_reference<_Gp>::type,
                                           __bind_r>::value
                               >::type>
      __attribute__ ((__visibility__("hidden"), __always_inline__))
      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)
        : base(std::__ndk1::forward<_Gp>(__f),
               std::__ndk1::forward<_BA>(__bound_args)...) {}

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,
                           result_type>::value,
            result_type
        >::type
        operator()(_Args&& ...__args)
        {
            return base::operator()(std::__ndk1::forward<_Args>(__args)...);
        }

    template <class ..._Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        typename enable_if
        <
            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,
                           result_type>::value,
            result_type
        >::type
        operator()(_Args&& ...__args) const
        {
            return base::operator()(std::__ndk1::forward<_Args>(__args)...);
        }
};

template<class _Rp, class _Fp, class ..._BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};

template<class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bind<_Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind<_Fp, _BoundArgs...> type;
    return type(std::__ndk1::forward<_Fp>(__f), std::__ndk1::forward<_BoundArgs>(__bound_args)...);
}

template<class _Rp, class _Fp, class ..._BoundArgs>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
__bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp&& __f, _BoundArgs&&... __bound_args)
{
    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
    return type(std::__ndk1::forward<_Fp>(__f), std::__ndk1::forward<_BoundArgs>(__bound_args)...);
}



template <>
struct __attribute__ ((__visibility__("default"))) hash<bool>
    : public unary_function<bool, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(bool __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<char>
    : public unary_function<char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(signed char __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned char __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char16_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(char32_t __v) const throw() {return static_cast<size_t>(__v);}
};



template <>
struct __attribute__ ((__visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(wchar_t __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<short>
    : public unary_function<short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned short __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<int>
    : public unary_function<int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned int __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<long>
    : public unary_function<long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(unsigned long __v) const throw() {return static_cast<size_t>(__v);}
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(float __v) const throw()
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(double __v) const throw()
    {

       if (__v == 0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};

template <>
struct __attribute__ ((__visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(long double __v) const throw()
    {

        if (__v == 0)
            return 0;
# 2394 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/functional" 3
        return __scalar_hash<long double>::operator()(__v);

    }
};


template <class _Tp>
struct __attribute__ ((__visibility__("default"))) hash
    : public unary_function<_Tp, size_t>
{
    static_assert(is_enum<_Tp>::value, "This hash only works for enumeration types");

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(_Tp __v) const throw()
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>{}(static_cast<type>(__v));
    }
};




} }
# 352 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 2 3
# 1 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdexcept" 1 3
# 50 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdexcept" 3
       
# 51 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/stdexcept" 3



namespace std { namespace __ndk1 {
class __attribute__ ((__visibility__("hidden"))) __libcpp_refstring {
    const char *__imp_;
};
} }


namespace std
{

class __attribute__ ((__visibility__("default"))) logic_error
    : public exception
{
private:
    std::__ndk1::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);

    logic_error(const logic_error&) throw();
    logic_error& operator=(const logic_error&) throw();

    virtual ~logic_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) runtime_error
    : public exception
{
private:
    std::__ndk1::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);

    runtime_error(const runtime_error&) throw();
    runtime_error& operator=(const runtime_error&) throw();

    virtual ~runtime_error() throw();

    virtual const char* what() const throw();
};

class __attribute__ ((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit domain_error(const char* __s) : logic_error(__s) {}

    virtual ~domain_error() throw();
};

class __attribute__ ((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const char* __s) : logic_error(__s) {}

    virtual ~invalid_argument() throw();
};

class __attribute__ ((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit length_error(const char* __s) : logic_error(__s) {}

    virtual ~length_error() throw();
};

class __attribute__ ((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const char* __s) : logic_error(__s) {}

    virtual ~out_of_range() throw();
};

class __attribute__ ((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit range_error(const char* __s) : runtime_error(__s) {}

    virtual ~range_error() throw();
};

class __attribute__ ((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~overflow_error() throw();
};

class __attribute__ ((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const char* __s) : runtime_error(__s) {}

    virtual ~underflow_error() throw();
};

}
# 353 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 2 3


       
# 356 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3


namespace std { namespace __ndk1 {

template <class _Key, class _Cp, class _Hash, bool = is_empty<_Hash>::value

                                         && !__is_final(_Hash)

         >
class __unordered_map_hasher
    : private _Hash
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __unordered_map_hasher()
       
        : _Hash() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __unordered_map_hasher(const _Hash& __h)
       
        : _Hash(__h) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _Hash& hash_function() const throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const _Cp& __x) const
        {return static_cast<const _Hash&>(*this)(__x.__cc.first);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const _Key& __x) const
        {return static_cast<const _Hash&>(*this)(__x);}
};

template <class _Key, class _Cp, class _Hash>
class __unordered_map_hasher<_Key, _Cp, _Hash, false>
{
    _Hash __hash_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __unordered_map_hasher()
       
        : __hash_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __unordered_map_hasher(const _Hash& __h)
       
        : __hash_(__h) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _Hash& hash_function() const throw() {return __hash_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const _Cp& __x) const
        {return __hash_(__x.__cc.first);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_t operator()(const _Key& __x) const
        {return __hash_(__x);}
};

template <class _Key, class _Cp, class _Pred, bool = is_empty<_Pred>::value

                                         && !__is_final(_Pred)

         >
class __unordered_map_equal
    : private _Pred
{
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __unordered_map_equal()
       
        : _Pred() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __unordered_map_equal(const _Pred& __p)
       
        : _Pred(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _Pred& key_eq() const throw() {return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Cp& __x, const _Cp& __y) const
        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y.__cc.first);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Cp& __x, const _Key& __y) const
        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Key& __x, const _Cp& __y) const
        {return static_cast<const _Pred&>(*this)(__x, __y.__cc.first);}
};

template <class _Key, class _Cp, class _Pred>
class __unordered_map_equal<_Key, _Cp, _Pred, false>
{
    _Pred __pred_;

public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __unordered_map_equal()
       
        : __pred_() {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __unordered_map_equal(const _Pred& __p)
       
        : __pred_(__p) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const _Pred& key_eq() const throw() {return __pred_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Cp& __x, const _Cp& __y) const
        {return __pred_(__x.__cc.first, __y.__cc.first);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Cp& __x, const _Key& __y) const
        {return __pred_(__x.__cc.first, __y);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool operator()(const _Key& __x, const _Cp& __y) const
        {return __pred_(__x, __y.__cc.first);}
};

template <class _Alloc>
class __hash_map_node_destructor
{
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::value_type::value_type value_type;
public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef typename value_type::value_type::first_type first_type;
    typedef typename value_type::value_type::second_type second_type;

    allocator_type& __na_;

    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __hash_map_node_destructor(allocator_type& __na) throw()
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)
        throw()
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }
# 516 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void operator()(pointer __p) throw()
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__ndk1::addressof(__p->__value_.__cc.second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__ndk1::addressof(__p->__value_.__cc.first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};



template <class _Key, class _Tp>
union __hash_value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;

    value_type __cc;
    __nc_value_type __nc;

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_value_type(_Args&& ...__args)
        : __cc(std::forward<_Args>(__args)...) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_value_type(const __hash_value_type& __v)
        : __cc(__v.__cc) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_value_type(__hash_value_type&& __v)
        : __nc(std::move(__v.__nc)) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_value_type& operator=(const __hash_value_type& __v)
        {__nc = __v.__cc; return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_value_type& operator=(__hash_value_type&& __v)
        {__nc = std::move(__v.__nc); return *this;}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    ~__hash_value_type() {__cc.~value_type();}
};
# 593 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
template <class _HashIterator>
class __attribute__ ((__visibility__("default"))) __hash_map_iterator
{
    _HashIterator __i_;

    typedef pointer_traits<typename _HashIterator::pointer> __pointer_traits;
    typedef const typename _HashIterator::value_type::value_type::first_type key_type;
    typedef typename _HashIterator::value_type::value_type::second_type mapped_type;
public:
    typedef forward_iterator_tag iterator_category;
    typedef pair<key_type, mapped_type> value_type;
    typedef typename _HashIterator::difference_type difference_type;
    typedef value_type& reference;
    typedef typename __pointer_traits::template



            rebind<value_type>::other

                                                                 pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_iterator() throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_iterator(_HashIterator __i) throw() : __i_(__i) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reference operator*() const {return __i_->__cc;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_iterator operator++(int)
    {
        __hash_map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_multimap;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_const_local_iterator;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_map_const_iterator;
};

template <class _HashIterator>
class __attribute__ ((__visibility__("default"))) __hash_map_const_iterator
{
    _HashIterator __i_;

    typedef pointer_traits<typename _HashIterator::pointer> __pointer_traits;
    typedef const typename _HashIterator::value_type::value_type::first_type key_type;
    typedef typename _HashIterator::value_type::value_type::second_type mapped_type;
public:
    typedef forward_iterator_tag iterator_category;
    typedef pair<key_type, mapped_type> value_type;
    typedef typename _HashIterator::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename __pointer_traits::template



            rebind<const value_type>::other

                                                                 pointer;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_const_iterator() throw() {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_const_iterator(_HashIterator __i) throw() : __i_(__i) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_const_iterator(
            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)
                 throw()
                : __i_(__i.__i_) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    reference operator*() const {return __i_->__cc;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    __hash_map_const_iterator operator++(int)
    {
        __hash_map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__))
        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_map;
    template <class, class, class, class, class> friend class __attribute__ ((__visibility__("default"))) unordered_multimap;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_const_iterator;
    template <class> friend class __attribute__ ((__visibility__("default"))) __hash_const_local_iterator;
};

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__visibility__("default"))) unordered_map
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef _Hash hasher;
    typedef _Pred key_equal;
    typedef _Alloc allocator_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_value_type<key_type, mapped_type> __value_type;
    typedef __unordered_map_hasher<key_type, __value_type, hasher> __hasher;
    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;
    typedef typename allocator_traits<allocator_type>::template



            rebind_alloc<__value_type>::other

                                                           __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal, __allocator_type> __table;

    __table __table_;

    typedef typename __table::__node_pointer __node_pointer;
    typedef typename __table::__node_const_pointer __node_const_pointer;
    typedef typename __table::__node_traits __node_traits;
    typedef typename __table::__node_allocator __node_allocator;
    typedef typename __table::__node __node;
    typedef __hash_map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    typedef allocator_traits<allocator_type> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator> iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_map()
       
        {



        }
    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),
                           const key_equal& __eql = key_equal());
    unordered_map(size_type __n, const hasher& __hf,
                  const key_equal& __eql,
                  const allocator_type& __a);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_map(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    explicit unordered_map(const allocator_type& __a);
    unordered_map(const unordered_map& __u);
    unordered_map(const unordered_map& __u, const allocator_type& __a);

    unordered_map(unordered_map&& __u)
        ;
    unordered_map(unordered_map&& __u, const allocator_type& __a);


    unordered_map(initializer_list<value_type> __il);
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
    unordered_map(initializer_list<value_type> __il, size_type __n,
                  const hasher& __hf, const key_equal& __eql,
                  const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf,
        const allocator_type& __a)
      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__il, __n, __hf, key_equal(), __a) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_map& operator=(const unordered_map& __u)
    {

        __table_ = __u.__table_;
# 843 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
        return *this;
    }

    unordered_map& operator=(unordered_map&& __u)
        ;


    unordered_map& operator=(initializer_list<value_type> __il);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw()
        {return allocator_type(__table_.__node_alloc());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw() {return __table_.size() == 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __table_.size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw() {return __table_.max_size();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() throw() {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() throw() {return __table_.end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw() {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw() {return __table_.end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw() {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw() {return __table_.end();}




    template <class... _Args>
        pair<iterator, bool> emplace(_Args&&... __args);

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
# 894 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
        iterator emplace_hint(const_iterator, _Args&&... __args)
            {return emplace(std::__ndk1::forward<_Args>(__args)...).first;}



    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator, bool> insert(const value_type& __x)
        {return __table_.__insert_unique(__x);}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        pair<iterator, bool> insert(_Pp&& __x)
            {return __table_.__insert_unique(std::__ndk1::forward<_Pp>(__x));}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
# 919 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
    iterator insert(const_iterator, const value_type& __x)
        {return insert(__x).first;}


    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
# 935 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
        iterator insert(const_iterator, _Pp&& __x)
            {return insert(std::__ndk1::forward<_Pp>(__x)).first;}


    template <class _InputIterator>
        void insert(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw() {__table_.clear();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(unordered_map& __u)
       
        {__table_.swap(__u.__table_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_unique(__k);}

    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


    mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type bucket_count() const throw() {return __table_.bucket_count();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_bucket_count() const throw() {return __table_.max_bucket_count();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    float load_factor() const throw() {return __table_.load_factor();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    float max_load_factor() const throw() {return __table_.max_load_factor();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 1038 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
private:

    __node_holder __construct_node();
    template <class _A0>
        __node_holder
         __construct_node(_A0&& __a0);
    __node_holder __construct_node_with_key(key_type&& __k);

    template <class _A0, class _A1, class ..._Args>
        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);


    __node_holder __construct_node_with_key(const key_type& __k);
};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const allocator_type& __a)
    : __table_(__a)
{



}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        const unordered_map& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u)
   
    : __table_(std::__ndk1::move(__u.__table_))
{




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        unordered_map&& __u, const allocator_type& __a)
    : __table_(std::__ndk1::move(__u.__table_), __a)
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
            __table_.__insert_unique(
                std::__ndk1::move(__u.__table_.remove((__i++).__i_)->__value_)
                                    );
    }




}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)
   
{
    __table_ = std::__ndk1::move(__u.__table_);
    return *this;
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_unique(__il.begin(), __il.end());
    return *this;
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node()
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_));
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0>
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_),
                             std::__ndk1::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(key_type&& __k)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_.__cc.first), std::__ndk1::move(__k));
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_.__cc.second));
    __h.get_deleter().__second_constructed = true;
    return __h;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0, class _A1, class ..._Args>
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0,
                                                                 _A1&& __a1,
                                                                 _Args&&... __args)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_),
                             std::__ndk1::forward<_A0>(__a0), std::__ndk1::forward<_A1>(__a1),
                             std::__ndk1::forward<_Args>(__args)...);
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class... _Args>
pair<typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator, bool>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__ndk1::forward<_Args>(__args)...);
    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
    if (__r.second)
        __h.release();
    return __r;
}




template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type& __k)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_.__cc.first), __k);
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_.__cc.second));
    __h.get_deleter().__second_constructed = true;
    return std::__ndk1::move(__h);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                       _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_unique(*__first);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)
{
    iterator __i = find(__k);
    if (__i != end())
        return __i->second;
    __node_holder __h = __construct_node_with_key(__k);
    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
    __h.release();
    return __r.first->second;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)
{
    iterator __i = find(__k);
    if (__i != end())
        return __i->second;
    __node_holder __h = __construct_node_with_key(std::__ndk1::move(__k));
    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
    __h.release();
    return __r.first->second;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)
{
    iterator __i = find(__k);




    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
const _Tp&
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const
{
    const_iterator __i = find(__k);




    return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
   
{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
            __i != __ex; ++__i)
    {
        const_iterator __j = __y.find(__i->first);
        if (__j == __ey || !(*__i == *__j))
            return false;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__visibility__("default"))) unordered_multimap
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef _Hash hasher;
    typedef _Pred key_equal;
    typedef _Alloc allocator_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type, mapped_type> __nc_value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");

private:
    typedef __hash_value_type<key_type, mapped_type> __value_type;
    typedef __unordered_map_hasher<key_type, __value_type, hasher> __hasher;
    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;
    typedef typename allocator_traits<allocator_type>::template



            rebind_alloc<__value_type>::other

                                                           __allocator_type;

    typedef __hash_table<__value_type, __hasher,
                         __key_equal, __allocator_type> __table;

    __table __table_;

    typedef typename __table::__node_traits __node_traits;
    typedef typename __table::__node_allocator __node_allocator;
    typedef typename __table::__node __node;
    typedef __hash_map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
    typedef allocator_traits<allocator_type> __alloc_traits;
public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;

    typedef __hash_map_iterator<typename __table::iterator> iterator;
    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_multimap()
       
        {



        }
    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),
                                const key_equal& __eql = key_equal());
    unordered_multimap(size_type __n, const hasher& __hf,
                                const key_equal& __eql,
                                const allocator_type& __a);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last);
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf = hasher(),
                      const key_equal& __eql = key_equal());
    template <class _InputIterator>
        unordered_multimap(_InputIterator __first, _InputIterator __last,
                      size_type __n, const hasher& __hf,
                      const key_equal& __eql,
                      const allocator_type& __a);
    explicit unordered_multimap(const allocator_type& __a);
    unordered_multimap(const unordered_multimap& __u);
    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);

    unordered_multimap(unordered_multimap&& __u)
        ;
    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);


    unordered_multimap(initializer_list<value_type> __il);
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf = hasher(),
                       const key_equal& __eql = key_equal());
    unordered_multimap(initializer_list<value_type> __il, size_type __n,
                       const hasher& __hf, const key_equal& __eql,
                       const allocator_type& __a);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}
    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"), __always_inline__))
      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf,
        const allocator_type& __a)
      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    unordered_multimap& operator=(const unordered_multimap& __u)
    {

        __table_ = __u.__table_;
# 1581 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
        return *this;
    }

    unordered_multimap& operator=(unordered_multimap&& __u)
        ;


    unordered_multimap& operator=(initializer_list<value_type> __il);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    allocator_type get_allocator() const throw()
        {return allocator_type(__table_.__node_alloc());}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    bool empty() const throw() {return __table_.size() == 0;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type size() const throw() {return __table_.size();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_size() const throw() {return __table_.max_size();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator begin() throw() {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator end() throw() {return __table_.end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator begin() const throw() {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator end() const throw() {return __table_.end();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cbegin() const throw() {return __table_.begin();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator cend() const throw() {return __table_.end();}




    template <class... _Args>
        iterator emplace(_Args&&... __args);

    template <class... _Args>
        iterator emplace_hint(const_iterator __p, _Args&&... __args);


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        iterator insert(_Pp&& __x)
            {return __table_.__insert_multi(std::__ndk1::forward<_Pp>(__x));}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator insert(const_iterator __p, const value_type& __x)
        {return __table_.__insert_multi(__p.__i_, __x);}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        iterator insert(const_iterator __p, _Pp&& __x)
            {return __table_.__insert_multi(__p.__i_, std::__ndk1::forward<_Pp>(__x));}

    template <class _InputIterator>
        void insert(_InputIterator __first, _InputIterator __last);

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator erase(const_iterator __first, const_iterator __last)
        {return __table_.erase(__first.__i_, __last.__i_);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void clear() throw() {__table_.clear();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void swap(unordered_multimap& __u)
       
        {__table_.swap(__u.__table_);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    hasher hash_function() const
        {return __table_.hash_function().hash_function();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    key_equal key_eq() const
        {return __table_.key_eq().key_eq();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    iterator find(const key_type& __k) {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<iterator, iterator> equal_range(const key_type& __k)
        {return __table_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        {return __table_.__equal_range_multi(__k);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type bucket_count() const throw() {return __table_.bucket_count();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type max_bucket_count() const throw()
        {return __table_.max_bucket_count();}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type bucket_size(size_type __n) const
        {return __table_.bucket_size(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    local_iterator begin(size_type __n) {return __table_.begin(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    local_iterator end(size_type __n) {return __table_.end(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator begin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator end(size_type __n) const {return __table_.cend(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    const_local_iterator cend(size_type __n) const {return __table_.cend(__n);}

    __attribute__ ((__visibility__("hidden"), __always_inline__))
    float load_factor() const throw() {return __table_.load_factor();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    float max_load_factor() const throw() {return __table_.max_load_factor();}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void rehash(size_type __n) {__table_.rehash(__n);}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    void reserve(size_type __n) {__table_.reserve(__n);}
# 1736 "/data/data/com.n0n3m4.droidc/files/gcc/aarch64-linux-android/include/c++/7.2.0/unordered_map" 3
private:

    __node_holder __construct_node();
    template <class _A0>
        __node_holder
         __construct_node(_A0&& __a0);

    template <class _A0, class _A1, class ..._Args>
        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);


};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        size_type __n, const hasher& __hf, const key_equal& __eql,
        const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last)
{



    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        _InputIterator __first, _InputIterator __last, size_type __n,
        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const allocator_type& __a)
    : __table_(__a)
{



}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u)
    : __table_(__u.__table_)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        const unordered_multimap& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a)
{



    __table_.rehash(__u.bucket_count());
    insert(__u.begin(), __u.end());
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u)
   
    : __table_(std::__ndk1::move(__u.__table_))
{




}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        unordered_multimap&& __u, const allocator_type& __a)
    : __table_(std::__ndk1::move(__u.__table_), __a)
{



    if (__a != __u.get_allocator())
    {
        iterator __i = __u.begin();
        while (__u.size() != 0)
        {
            __table_.__insert_multi(
                std::__ndk1::move(__u.__table_.remove((__i++).__i_)->__value_)
                                   );
        }
    }




}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il)
{



    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql)
    : __table_(__hf, __eql)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a)
{



    __table_.rehash(__n);
    insert(__il.begin(), __il.end());
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)
   
{
    __table_ = std::__ndk1::move(__u.__table_);
    return *this;
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(
        initializer_list<value_type> __il)
{
    __table_.__assign_multi(__il.begin(), __il.end());
    return *this;
}





template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node()
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_));
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0>
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_),
                             std::__ndk1::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _A0, class _A1, class ..._Args>
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(
        _A0&& __a0, _A1&& __a1, _Args&&... __args)
{
    __node_allocator& __na = __table_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, std::__ndk1::addressof(__h->__value_),
                             std::__ndk1::forward<_A0>(__a0), std::__ndk1::forward<_A1>(__a1),
                             std::__ndk1::forward<_Args>(__args)...);
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class... _Args>
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__ndk1::forward<_Args>(__args)...);
    iterator __r = __table_.__node_insert_multi(__h.get());
    __h.release();
    return __r;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class... _Args>
typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace_hint(
        const_iterator __p, _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__ndk1::forward<_Args>(__args)...);
    iterator __r = __table_.__node_insert_multi(__p.__i_, __h.get());
    __h.release();
    return __r;
}




template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
                                                            _InputIterator __last)
{
    for (; __first != __last; ++__first)
        __table_.__insert_multi(*__first);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
   
{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
bool
operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    if (__x.size() != __y.size())
        return false;
    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator
                                                                 const_iterator;
    typedef pair<const_iterator, const_iterator> _EqRng;
    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
    {
        _EqRng __xeq = __x.equal_range(__i->first);
        _EqRng __yeq = __y.equal_range(__i->first);
        if (std::__ndk1::distance(__xeq.first, __xeq.second) !=
            std::__ndk1::distance(__yeq.first, __yeq.second) ||
                  !std::__ndk1::is_permutation(__xeq.first, __xeq.second, __yeq.first))
            return false;
        __i = __xeq.second;
    }
    return true;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
bool
operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
{
    return !(__x == __y);
}

} }
# 1 "PreProcTest.cxx" 2
